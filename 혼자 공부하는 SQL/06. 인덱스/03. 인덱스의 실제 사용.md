# 6.3 인덱스의 실제 사용
- 인덱스 생성는 CREATE INDEX, 제거는 DROP INDEX 문 사용. 기본 형식은 다음과 같음.
```mysql
create [unique] index 인덱스_이름
    on 테이블_이름 (열_이름) [asc | desc]
```
```mysql
drop index 인덱스_이름 on 테이블_이름
```
- 보조 인덱스는 데이터의 중복 여부에 따라 단순 보조 인덱스와 고유 보조 인덱스로 나뉨.

## 인덱스 생성과 제거 문법
### 인덱스 생성 문법
- 테이블을 생성할 떼 특정 열을 기본 키, 고유 키로 설정하면 인덱스가 자동 생성됨. pk 문법을 사용하면 클러스터형 인덱스가, unique 문법을 사용하면 보조 인덱스가 자동으로 생성되었음.
- 그 외 직접 인덱스를 생성하려면 create index 문을 사용해야 함. mysql 도움말에서 안내하는 인덱스 생성하는 문법은 다음과 같음.
```mysql
CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name
    [index_type]
    ON tbl_name (key_part,...)
    [index_option]
    [algorithm_option | lock_option] ...

key_part: {col_name [(length)] | (expr)} [ASC | DESC]

index_option: {
    KEY_BLOCK_SIZE [=] value
  | index_type
  | WITH PARSER parser_name
  | COMMENT 'string'
  | {VISIBLE | INVISIBLE}
  | ENGINE_ATTRIBUTE [=] 'string'
  | SECONDARY_ENGINE_ATTRIBUTE [=] 'string'
}

index_type:
    USING {BTREE | HASH}

algorithm_option:
    ALGORITHM [=] {DEFAULT | INPLACE | COPY}

lock_option:
    LOCK [=] {DEFAULT | NONE | SHARED | EXCLUSIVE}
```
- 좀 복잡해 보이지만, 실제로 사용하는 것은 다음과 같음.
```mysql
create [unique] index 인덱스_이름
    on 테이블_이름 (열_이름) [asc | desc]
```
- unique는 중복이 안 되는 고유 인덱스를 만드는 것. 생략시 중복 허용. create unique로 인덱스를 생성하려면 기존에 입력된 값들에 중복이 있으면 안 됨. 그리고 인덱스 생성 후에 입력되는 데이터와도
중복 불가.
- 같을 수도 있는 이름과 같은 성격을 가진 열에는 unique로 지정하면 안 되고, 휴대폰 번호, 이메일 등은 unique로 지정해도 별 문제 없음.
- asc 또는 desc 는 인덱를 오름차순으로 만들어줌. 기본은 asc.

### 인덱스 제거 문법
```mysql
drop index 인덱스_이름 on 테이블_이름
```
- 주의할 점은 기본 키, 고유 키로 자동 생성된 인덱스는 drop index로 제거하지 못함. alter table 문으로 기본 키나 고유 키를 제거하면 자동으로 생성된 인덱스도 제거 가능.

## 인덱스 생성과 제거 실습
### 인덱스 생성 실습
```mysql
use market_db;
select * from member;
```
```text
+--------+--------------+------------+--------+--------+----------+--------+------------+
| mem_id | mem_name     | mem_number | addr   | phone1 | phone2   | height | debut_date |
+--------+--------------+------------+--------+--------+----------+--------+------------+
| APN    | 에이핑크     |          6 | 경기   | 031    | 77777777 |    164 | 2011-02-10 |
| BLK    | 블랙핑크     |          4 | 경남   | 055    | 22222222 |    163 | 2016-08-08 |
| GRL    | 소녀시대     |          8 | 서울   | 02     | 44444444 |    168 | 2007-08-02 |
| ITZ    | 잇지         |          5 | 경남   | NULL   | NULL     |    167 | 2019-02-12 |
| MMU    | 마마무       |          4 | 전남   | 061    | 99999999 |    165 | 2014-06-19 |
| OMY    | 오마이걸     |          7 | 서울   | NULL   | NULL     |    160 | 2015-04-21 |
| RED    | 레드벨벳     |          4 | 경북   | 054    | 55555555 |    161 | 2014-08-01 |
| SPC    | 우주소녀     |         13 | 서울   | 02     | 88888888 |    162 | 2016-02-25 |
| TWC    | 트와이스     |          9 | 서울   | 02     | 11111111 |    167 | 2015-10-19 |
| WMN    | 여자친구     |          6 | 경기   | 031    | 33333333 |    166 | 2015-01-15 |
+--------+--------------+------------+--------+--------+----------+--------+------------+
10 rows in set (0.00 sec)
```
- show index 문으로 member에 어떤 인덱스가 설정되어 있는 지 확인.
```mysql
show index from member;
```
```text
+--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| member |          0 | PRIMARY  |            1 | mem_id      | A         |           2 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
+--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
1 row in set (0.01 sec)
```
- key_name이 primary이면 클러스터형 인덱스를 의미. mem_id 열에 클러스터형 인덱스 1개만 설정되어 있음.
- 다음으로 인덱스의 크기를 확인해보자.
```mysql
show table status like 'member';
```
```text
show table status like 'member';
+--------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+--------------------+----------+----------------+---------+
| Name   | Engine | Version | Row_format | Rows | Avg_row_length | Data_length | Max_data_length | Index_length | Data_free | Auto_increment | Create_time         | Update_time         | Check_time | Collation          | Checksum | Create_options | Comment |
+--------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+--------------------+----------+----------------+---------+
| member | InnoDB |      10 | Dynamic    |   10 |           1638 |       16384 |               0 |            0 |         0 |           NULL | 2023-07-28 15:33:56 | 2023-07-28 15:33:56 | NULL       | utf8mb4_0900_ai_ci |     NULL |                |         |
+--------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+--------------------+----------+----------------+---------+
1 row in set (0.01 sec)
```
- Data_length는 클러스터형 인덱스(또는 데이터)의 크기를 Byte 단위로 표기한 것. MySQL의 1페이지 크기는 기본적으로 16KB이므로 클러스터형 인덱스는 16384/(16 * 1024) = 1 페이지가 할당되어 있는 것.
- 실제로는 데이터의 내용이 많지 않아서 16kb까지 필요 없지만, 최소 단위가 1페이지이므로 1페이지에 해당하는 16KB가 할당되어 있는 것. Index_length는 보조 인덱스의 크기로 현재 없어 0.
- 이미 클러스터형 인덱스가 존재해 더 이상 클러스터형 인덱스는 생성 못함. 주소(addr)에 중복을 허용하는 단순 보조 인덱스를 생성하자.
```mysql
create index idx_member_addr
    on member(addr);
```
- 보조 인덱스는 단순 보조 인덱스와 고유 보조 인덱스로 나뉨. 단순 보조 인덱스는 중복 허용. 고유 보조 인덱스와 반대.
```mysql
show index from member;
```
```text
+--------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table  | Non_unique | Key_name        | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+--------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| member |          0 | PRIMARY         |            1 | mem_id      | A         |           2 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| member |          1 | idx_member_addr |            1 | addr        | A         |           5 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
+--------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
2 rows in set (0.00 sec)
```
- non_unique가 1로 설정되어 있으므로 고유 보조 인덱스가 아니라는 뜻. 즉, 중복 허용.
- 클러스터형 인덱스와 보조 인덱스가 동시에 있다는 것은 영어사전이면서 동시에 찾아보기도 존재한다는 것.
- 다음으로 전체 인덱스의 크기를 다시 확인해보자.
```mysql
show table status like 'member';
```
```text
+--------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+--------------------+----------+----------------+---------+
| Name   | Engine | Version | Row_format | Rows | Avg_row_length | Data_length | Max_data_length | Index_length | Data_free | Auto_increment | Create_time         | Update_time         | Check_time | Collation          | Checksum | Create_options | Comment |
+--------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+--------------------+----------+----------------+---------+
| member | InnoDB |      10 | Dynamic    |   10 |           1638 |       16384 |               0 |            0 |         0 |           NULL | 2023-07-28 15:42:51 | 2023-07-28 15:33:56 | NULL       | utf8mb4_0900_ai_ci |     NULL |                |         |
+--------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+--------------------+----------+----------------+---------+
1 row in set (0.00 sec)
```
- 보조 인덱스가 추가되었음에도 Index_length가 0이다. 생성한 인덱스를 실제로 적용시키려면 analyze table 문으로 먼저 테이블을 분석/처리해주어야 함.
```mysql
analyze table member;
```
```text
+------------------+---------+----------+----------+
| Table            | Op      | Msg_type | Msg_text |
+------------------+---------+----------+----------+
| market_db.member | analyze | status   | OK       |
+------------------+---------+----------+----------+
1 row in set (0.01 sec)
```
```mysql
show table status like 'member';
```
```text
+--------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+--------------------+----------+----------------+---------+
| Name   | Engine | Version | Row_format | Rows | Avg_row_length | Data_length | Max_data_length | Index_length | Data_free | Auto_increment | Create_time         | Update_time         | Check_time | Collation          | Checksum | Create_options | Comment |
+--------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+--------------------+----------+----------------+---------+
| member | InnoDB |      10 | Dynamic    |   10 |           1638 |       16384 |               0 |        16384 |         0 |           NULL | 2023-07-28 15:42:51 | 2023-07-28 15:33:56 | NULL       | utf8mb4_0900_ai_ci |     NULL |                |         |
+--------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+--------------------+----------+----------------+---------+
1 row in set (0.00 sec)
```
- Index_length의 크기는 16KB 가 되었음.
- 다음으로 인원수 (mem_number)에 중복을 허용하지 않는 고유 보조 인덱스를 생성해보자. 이미 중복된 값이 있기에 고유 보조 인덱스를 생성할 수 없음.
```mysql
create unique index idex_member_mem_number
    on member (mem_number);
```
```text
ERROR 1062 (23000): Duplicate entry '4' for key 'member.idex_member_mem_number'
```
- 이번에는 회원 이름(mem_name)에 고유 보조 인덱스를 생성해보자.
```mysql
create unique index idx_member_mem_name
    on member(mem_name);
```
```mysql
show index from member;
```
```text
+--------+------------+---------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table  | Non_unique | Key_name            | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+--------+------------+---------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| member |          0 | PRIMARY             |            1 | mem_id      | A         |          10 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| member |          0 | idx_member_mem_name |            1 | mem_name    | A         |          10 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| member |          1 | idx_member_addr     |            1 | addr        | A         |           5 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
+--------+------------+---------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
3 rows in set (0.01 sec)
```
- Non_unique가 0이라는 것은 중복을 허용하지 않는다는 의미로, 고유 보조 인덱스가 잘 생성된 것.
- 이번에는 이름이 같은 그룹이 회원가입을 한다고 가정. 기본 키만 다르면 되므로 insert 문을 작성해보자.
```mysql
insert into member values('MOO', '마마무', 2, '태국', '001', '12341234', 155, '2020.10.10');
```
```text
ERROR 1062 (23000): Duplicate entry '마마무' for key 'member.idx_member_mem_name'
```
- 오류가 발생함. 조금 전 생성한 고유 보조 인덱스로 인해 중복된 값을 입력할 수 없기 때문.
- 이렇게 이름이 중복되어 회원가입이 안 된다면 실제 서비스에서 심각한 문제가 발생할 수 있음. 그러므로 고유 보조 인덱스를 지정할 때 현재 중복된 값이 없다고 무조건 설정하면 안 되며, 업무상 절대로 중복되지
않는 열(주민번호, 학번, 이메일 등)만 unique 옵션을 사용해 인덱스를 생성해야 함.

### 인덱스의 활용 실습
- 생성한 인덱스를 활용해보자. 
- 먼저 지금까지 만든 인덱스가 어느 열에 있는지 확인해보자.
```mysql
analyze table member;
show index from member;
```
```text
+--------+------------+---------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table  | Non_unique | Key_name            | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+--------+------------+---------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| member |          0 | PRIMARY             |            1 | mem_id      | A         |          10 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| member |          0 | idx_member_mem_name |            1 | mem_name    | A         |          10 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| member |          1 | idx_member_addr     |            1 | addr        | A         |           5 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
+--------+------------+---------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
3 rows in set (0.00 sec)
``` 
- mem_id, mem_name, addr 열에 인덱스가 존재.
- 일단 전체를 조회해 보자. 그리고 [Execution Plan] 창을 확인해 어떻게 검색하였는지 확인해보자.
```mysql
select * from member;
```
- MySQL Workbench에서 Full Table Scan을 한 것을 확인할 수 있음.
- 다음으로 인덱스가 있는 열을 조회해 보자.
```mysql
select mem_id, mem_name, addr from member;
```
- 인덱스가 있는 열임에도 전체 테이블 검색을 한 것을 확인할 수 있음.
- 이번에는 인덱스가 생성된 mem_name 값이 '에이핑크'인 값을 조회해 보자.
```mysql
select mem_id, mem_name, addr
    from member where mem_name = '에이핑크';
```
- execution plan 창을 확인해보면 Single Row(constant) 라고 되어 있음. 이 용어는 인덱스를 사용해서 결과를 얻었다는 의미. 즉, where 절에 열 이름이 들어 있어야 인덱스를 사용함.
- 이번에는 숫자의 범위로 조회해보자. 먼저 숫자로 구성된 인원수(mem_number)로 단순 보조 인덱스를 만들어보자.
```mysql
create index idx_mem_number
    on member (mem_number);
analyze table member;
```
```mysql
select mem_name, mem_number
    from member
    where mem_number >= 7;
```
```text

+--------------+------------+
| mem_name     | mem_number |
+--------------+------------+
| 오마이걸     |          7 |
| 소녀시대     |          8 |
| 트와이스     |          9 |
| 우주소녀     |         13 |
+--------------+------------+
4 rows in set (0.00 sec)
```
- Execution Plan을 확인해보면 Index Range Scan 이라고 인덱스를 사용한 것을 확인할 수 있음.

### 인덱스를 사용하지 않을 때
- 인덱스가 있고 where 열에 열 이름이 나와도 인덱스를 사용하지 않는 경우 존재. 인원 수가 1명 이상인 회원을 조회해보자. 회원은 1명 이상이므로 10건 모두 조회됨.
```mysql
select mem_name, mem_number
    from member
    where mem_number >= 1;
```
```text
+--------------+------------+
| mem_name     | mem_number |
+--------------+------------+
| 에이핑크     |          6 |
| 블랙핑크     |          4 |
| 소녀시대     |          8 |
| 잇지         |          5 |
| 마마무       |          4 |
| 오마이걸     |          7 |
| 레드벨벳     |          4 |
| 우주소녀     |         13 |
| 트와이스     |          9 |
| 여자친구     |          6 |
+--------------+------------+
10 rows in set (0.00 sec)
```
- Execution Plan을 확인해보면 전체 테이블을 검색한 것을 확인할 수 있음. 인덱스가 있더라도 MySQL이 인덱스 검색보다는 전체 테이블 검색이 낫겠다고 판단했기 때문.
- 이 경우에는 대부분의 행을 가져와야 하므로 인덱스를 왔다 갔다 하는 것보다는 차라리 테이블을 차례대로 읽는 것이 효율적.
- 찾을 건수가 엄청 많을 때, 책의 제일 뒤에 있는 찾아보기에서 본문까지 왔다 갔다 하는 것보다 처음부터 읽는 것이 나은 것과 마찬가지.
- 또 다른 경우 where 절에서 열에 연산이 가해지는 경우를 확인해보자.
```mysql
select mem_name, mem_number
    from member
    where mem_number * 2 >= 14;
```
```text
+--------------+------------+
| mem_name     | mem_number |
+--------------+------------+
| 소녀시대     |          8 |
| 오마이걸     |          7 |
| 우주소녀     |         13 |
| 트와이스     |          9 |
+--------------+------------+
4 rows in set (0.00 sec)
```
- Execution Plan 을 확인해보면 전체 테이블 검색을 한 것을 볼 수 있음.
- 이런 경우에는 다음과 같이 수정을 하면 됨.
```mysql
select mem_name, mem_number
    from member
    where mem_number >= 14 / 2;
```
- Execution plan을 살펴보면 인덱스를 사용했음.

### 인덱스 제거 실습
```mysql
show index from member;
```
```text
+--------+------------+---------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table  | Non_unique | Key_name            | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+--------+------------+---------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| member |          0 | PRIMARY             |            1 | mem_id      | A         |          10 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| member |          0 | idx_member_mem_name |            1 | mem_name    | A         |          10 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| member |          1 | idx_member_addr     |            1 | addr        | A         |           5 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| member |          1 | idx_mem_number      |            1 | mem_number  | A         |           7 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
+--------+------------+---------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
4 rows in set (0.00 sec)
```
- 클러스터형 인덱스와 보조 인덱스가 섞여 있을 때는 보조 인덱스를 먼저 제거하는 것이 좋음. 보조 인덱스는 어떤 것을 먼저 제거해도 상관없음.
```mysql
drop index idx_member_mem_name on member;
drop index idx_member_addr on member;
drop index idx_mem_number on member;
```
- 마지막으로 기본 키 지정으로 자동 생성된 클러스터형 인덱스를 제거하면 됨. Primary Key 에 설정된 인덱스는 drop index 문으로 제거되지 않고, alter table 문으로만 제거 가능.
```mysql
alter table member
    drop primary key ;
```
```text
ERROR 1553 (HY000): Cannot drop index 'PRIMARY': needed in a foreign key constraint
```
- member의 mem_id 열을 buy 가 참조하고 있어 오류 발생. 그러므로 기본 키를 제거하기 전에 외래 키 관계를 제거해야 함.
- 테이블에는 여러 개의 외래 키가 있을 수 있음. 그래서 먼저 외래 키의 이름을 알아내야 함. information_schema 데이터베이스의 referential_constraints 테이블을 조회하면 외래 키 이름을 알 수 있음.
```mysql
select table_name, constraint_name
    from information_schema.REFERENTIAL_CONSTRAINTS
    where CONSTRAINT_SCHEMA = 'market_db';
```
```text
+------------+-----------------+
| TABLE_NAME | CONSTRAINT_NAME |
+------------+-----------------+
| buy        | buy_ibfk_1      |
+------------+-----------------+
1 row in set (0.00 sec)
```
- 이제 외래 키 이름을 알았으니 외래 키를 먼저 제거하고 기본 키를 제거하면 됨. 이제 모든 인덱스가 제거됨.
```mysql
alter table buy
    drop foreign key buy_ibfk_1;
alter table member
    drop primary key ;
```

## 인덱스를 효과적으로 사용하는 방법
### 인덱스는 열 단위에 생성됨.
- 하나의 열에 하나의 인덱스를 생성할 수 있음.
- 사실 하나의 열에 2개 이상의 인덱스 또는 2개 이상의 열을 묶어서 하나의 인덱스로 만들 수도 있지만, 이런 경우는 드물기 때문에 하나의 열에 하나의 인덱스를 만드는 것이 가장 일반적.

### where 절에서 사용되는 열에 인덱스를 만들어야 함.
- select 문을 사용할 때, where 조건에 해당 열이 나와야 인덱스를 사용함. 그 외에 다른 열에 인덱스를 만드는 것은 낭비가 됨.

### where 절에 사용되더라도 자주 사용해야 가치가 있음.
- 만약 mem_name 열에 인덱스를 생성해서 효율이 아주 좋아진다 하더라도, 이 select 문이 1년에 1번 정도만 사용되고 member 테이블에는 주로 insert 작업만 일어난다면 어떨까?
- 인덱스는 insert 의 성능을 나쁘게 하므로 오히려 성능이 나빠지는 결과가 될 것. 차라리 1년에 1번쯤 인덱스 없이 select 하는 것이 더 나음.

### 데이터의 중복이 높은 열은 인덱스를 만들어도 별 효과가 없음.
- 열에 들어갈 데이터의 종류가 몇 가지 되지 않으면 인덱스가 큰 효과를 내지 못함. 예를 들어 성별, 연락처 국번, 주로 사용하는 교통 수단 등 종류가 제한된 것에는 인덱스를 만들어도 효과가 없음.

### 클러스터형 인덱스는 테이블당 하나만 생성 가능.
- 클러스터형 인덱스는 데이터 페이지를 읽는 수가 보조 인덱스보다 적기 때문에 성능이 더 우수함.
- 그러므로 하나밖에 지정하지 못하는 클러스터형 인덱스(기본 키)는 조회할 때 가장 많이 사용되는 열에 지정하는 것이 효과적

### 사용하지 않는 인덱스는 제거함.
- 실제로 사용되는 SQL을 분석해서 where 조건에서 사용되지 않는 열의 인덱스는 제거할 필요가 있음. 그러면 공간을 확보할 뿐 아니라 데이터 입력 시 발생하는 부하도 많이 줄일 수 있음.

## 핵심 정리
- create index 문으로 인덱스를 직접 생성함.
- 기본 키 및 고유 키로 자동 생성된 인덱스는 alter table 로 제거하고, create index 문으로 생성한 인덱스는 drop index 문으로 제거함.
- 단순 보조 인덱스는 중복을 허용하는 보조 인덱스이며, create index 문을 사용함.
- 고유 보조 인덱스는 중복을 허용하지 않는 보조 인덱스이며, create unique index 문을 사용함.
- MySQL 워크벤치에서 sql을 실행한 후, 실행 계획에서 인덱스의 사용 여부를 확인 가능.

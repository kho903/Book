# 11.1 CPU 스케줄링 개요
- 모든 프로세스는 CPU를 필요로 하고 모든 프로세스는 먼저 CPU를 사용하고 싶어 함. 이러한 프로세스들에게 공정하고 합리적으로 CPU 자원을 할당하기 위해 운영체제는 어떤 프로세스에 CPU를 할당할지,
기다리게 할지, 배분하는 것을 CPU 스케줄링 (CPU scheduling)이라고 한다. CPU 스케줄링은 컴퓨터 성능과도 직결되는 중요한 문제.

## 프로세스 우선순위
- 아주 단순히, CPU를 사용하고 싶어 하는 프로세스들이 차례로 돌아가며 CPU를 이용하게 하는 방법이 있는데, 사실 이는 좋은 방법이 아니다.
- 그 이유로 프로세스마다 우선순위가 다르기 때문. 우선순위가 높은 프로세스란 빨리 처리해야 하는 프로세스들을 의미. 대표적으로 입출력 작업이 많은 프로세스가 있다. 왜 그럴까?
- 이를 이해하려면 일반적으로 프로세스가 어떤 과정을 거치며 실행되는지 생각해야 한다. 대부분의 프로세스들은 CPU와 입출력장치를 모두 사용하며 실행된다. 즉, 실행 상태와 대기 상태 반복하며 실행된다.
- 예를 들어 워드 프로세서는 CPU를 사용하여 명령어를 실행, 사용자로부터 입력받은 내용은 보조기억장치에 저장, CPU를 사용해 명령어 실행, 사용자 입력 내용을 화면에 출력하는 과정을 반복하며 실행된다.
- 그런데 프로세스 종류마다 입출력장치를 이용하는 시간과 CPU를 이용하는 시간의 양에는 차이가 있다. 비디오 재생, 디스크 백업 담당 프로세스는 입출력 작업이 많은 프로세스, 복잡한 수학, 컴파일,
그래픽 처리 작업 프로세스는 CPU 작업이 많은 프로세스이다. 전자를 입출력 집중 프로세스 (I/O bound process), 후자를 CPU 집중 프로세스(CPU bound process)라 한다.
    - CPU를 이용하는 작업을 CPU 버스트(CPU burst), 입출력장치를 기다리는 작업을 입출력 버스트(I/O burst)라 부른다.
- 입출력 집중 프로세스는 실행 상태보다는 입출력을 위한 대기 상태에 더 많이 머무르게 되고 CPU 집중 프로세스는 대기 상태보다는 실행 상태에 더 많이 머무르게 된다.
- CPU 집중 프로세스는 CPU를 많이 사용해야 하는 프로세스, 입출력 집중 프로세스는 그렇지 않은 프로세스인데, 두 종류의 프로세스가 모두 동일한 빈도로 CPU를 사용하는 것은 비합리적. 두 종류의
프로세스가 동시에 CPU 자원을 요구했다고 가정하면 이러한 경우, 입출력 집중 프로세스를 가능한 한 빨리 실행시켜 입출력장치를 끊임없이 작동시키고, 그 다음 CPU 집중 프로세스에 집중적으로 CPU를
할당하는 것이 더 효율적. 입출력장치가 입출력 작업을 완료하기 전까지는 입출력 집중 프로세스는 어차피 대기 상태가 될 예정이기 때문에, 입출력 집중 프로세스를 얼른 먼저 처리해 버리면 다른 프로세스가
CPU를 사용할 수 있기 때문.
- 이렇게 모든 프로세스가 CPU를 차례대로 돌아가며 사용하는 것보다 각각의 상황에 맞게 CPU를 배분하는 것이 더 효율적.
- 상황에 맞게, 프로세스의 중요도에 맞게 프로세스가 CPU를 이용할 수 있도록 운영체제는 프로세스마다 우선순위(priority) 부여. 운영체제는 각 프로세스의 PCB에 우선순위를 명시하고, PCB에 적힌
우선순위를 기준으로 먼저 처리할 프로세스를 결정. 그렇게 자연스레 우선순위가 높은 프로세스는 더 빨리, 더 자주 실행됨.

## 스케줄링 큐
- PCB에 우선순위가 적혀 있다고는 하지만, CPU를 사용한 다음 프로세스를 찾기 위해 운영체제가 일일이 모든 프로세스의 PCB를 뒤적거리는 것은 비효율적. CPU를 원하는 프로세스들은 한 두 개가 아니고,
CPU 요구하는 새로운 프로세스는 언제든 생길 수 있다.
- 그래서 운영체제는 프로세스들에 '줄을 서서 기다릴 것'을 요구. CPU를 사용하고 싶은 프로세스들, 메모리에 적재되고 싶은 프로세스들, 특정 입출력장치를 사용하고 싶은 프로세스들을 모두 줄세우는 것.
이 줄을 스케줄링 큐(scheduling queue)로 구현하고 관리함. 스케줄링 큐는 반드시 선입선출 방식일 필요는 없다.
- 즉, 운영체제는 메모리로 적재되고 싶은 (새로 생성되는) 프로세스들을 큐에 삽입하여 줄을 세우고, CPU를 이용하고 싶은 프로세스들 또한 큐에 삽입하여 줄을 세우고, 특정 입출력장치를 이용하고 싶은
프로세스들 역시 큐에 삽입하여 줄을 세운다.
- 운영체제가 관리하는 대부분의 자원은 이렇듯 큐로 관리됨. 그래서 운영체제가 관리하는 줄, 즉 큐에는 다양한 종류가 있다. 대표적인 큐로 준비 큐와 대기 큐.
- 준비 큐(ready queue)는 CPU를 이용하고 싶은 프로세스들이 서는 줄. 대기 큐(waiting queue)는 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄.
- 준비 상태에 있는 프로세스들의 PCB는 준비 큐의 마지막에 삽입되어 CPU를 사용할 차례를 기자리고 운영체제는 큐에 삽입된 순서대로 프로세스를 하나씩 꺼내어 실행하되, 그중 우선순위가 높은 프로세스를
먼저 실행. 우선순위가 낮은 프로세스들이 먼저 큐에 삽입되었어도 높은 프로세스는 그들보다 먼저 처리될 수 있다.
- 대기 상태에 있는 프로세스도 같은 장치를 요구한 프로세스들은 같은 대기 큐에서 기다린다. 입출력이 완료되어 완료 인터럽트가 발생하면 운영체제는 대기 큐에서 작업이 완료된 PCB를 찾고, 이 PCB를
준비 상태로 변경한 뒤 대기 큐에서 제거한다. 당연히 해당 PCB는 준비 큐로 이동.

## 선점형과 비선점형 스케줄링
- 운영체제가 지금 사용 중인 프로세스로부터 CPU 자원을 빼앗아 다른 프로세스에 할당할 수도 있고, CPU를 사용 중인 프로세스의 작업이 끝날 때까지 다른 급한 프로세스를 기다리게 할 수도 있다.
이 방법을 각각 선점형 스케줄링과 비선점형 스케줄링이라고 한다.
- 선점이란 '남보다 엎서서 차지함'을 의미. 선점형 스케줄링(preemptive scheduling)은 프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른
프로세스에 할당할 수 있는 스케줄링 방식을 의미. 다시 말해 어느 하나의 프로세스가 자원 사용을 독점할 수 없는 방식으로, 앞서 말한 스케줄링 방식은 모두 선점형 스케줄링의 일종.
- 프로세스마다 정해진 시간만큼 CPU를 사용하고, 정해진 시간을 모두 소비하여 타이머 인터럽트가 발생하면 운영체제가 해당 프로세스로부터 CPU 자원을 빼앗아 다음 프로세스에 할당하는 방식은 선점형
스케줄링의 일종으로 볼 수 있다.
- 반면, 비선점형 스케줄링(non-preemptive scheduling)이란 하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까진 다른 프로세스가 끼어들 수 
없는 스케줄링 방식. 즉, 하나의 프로세스가 자원을 독점할 수 있는 방식. 만약 비선점형 스케줄링 방식으로 자원을 이용하는 프로세스가 있다면 다른 프로세스는 그 프로세스의 사용이 모두 끝날 때까지
기다려야 한다.
- 현재 대부분의 운영체제는 선점형 스케줄링 방식을 차용하고 있지만, 각각 장단점이 있다.
- 선점형 스케줄링은 더 급한 프로세스가 언제든 끼어들어 사용할 수 있어, 어느 한 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원 배분 가능하다는 장점이 있지만, 그만큼 문맥 교환 과정에서
오버헤드 발생 가능.
- 반면 비선점형 스케줄링은 문맥 교환의 횟수가 선점형 스케줄링보다 적어 문맥 교환에서 오버헤드가 선점형 스케줄링보다 적지만, 하나의 프로세스가 자원을 사용 중이라면 당장 자원을 사용해야 하는
상황에서도 무작적 기다려야 한다. 모든 프로세스가 골고루 자원을 사용할 수 없다는 단점이 있다.

## 키워드 정리
- CPU 스케줄링은 공정하고 합리적으로 CPU 자원을 배분하는 방법을 의미.
- 프로세스는 우선순위를 가지고 있고, 이는 PCB에 명시됨.
- 운영체제는 효율적인 스케줄링을 위해 스케줄링 큐 사용.
- 준비 큐는 CPU 할당을 기다리는 프로세스들을 위한 큐를 의미.
- 대기 큐는 입출력장치를 기다리는 프로세스들을 위한 큐를 의미.
- 선점형 스케줄링은 프로세스가 이용 중인 자원을 빼앗을 수 있다.
- 비선점형 스케줄링은 프로세스가 이용 중인 자원을 빼앗을 수 없다.

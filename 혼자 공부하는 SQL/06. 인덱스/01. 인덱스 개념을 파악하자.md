# 6.1 인덱스 개념을 파악하자
- 인덱스(index)는 데이터를 빠르게 찾을 수 있도록 도와주는 도구로, 실무에서는 필수.
- 클러스터형 인덱스(Clustered Index)와 보조 인덱스(Secondary Index)가 있음.
- 클러스터형 인덱스는 기본 키 지정시 자동 생성, 테이블당 1개, 기본 키로 지정한 열 기준으로 자동 정렬됨.
- 보조 인덱스는 고유 키로 지정하면 자동 생성되며 여러 개 만들 수 있지만 자동정렬 X.

## 인덱스의 개념
- 인덱스는 책의 '찾아보기' (색인)과 같음. 찾아보기가 없는 책이면 처음부터 끝까지 넘겨가며 찾아야 함.
- 인덱스는 데이터를 빠르게 찾을 수 있도록 해주는 도구로, 인덱스 사용 여부에 따라 성능 차이가 날 수 있음. 대용량일 경우 더더욱.

### 인덱스의 문제점
- 인덱스를 이해하지 못한 채 좋다고 남용하는 것을 주의해야함.
- 인덱스 또한 문제점도 존재. 찾아보기에 만들지 않아도 될 단어들이 쌓이면 쓸데 없이 책의 두께만 두꺼워지고, 찾아보기를 사용했는데도 오히려 더 오래 걸릴 수 있음.
- 실무 역시 필요 없는 인덱스를 만드는 바람에 데이터베이스 차지 공간만 늘어나고 느려질 수 있음.

#### 똑똑한 MySQL
- 데이터베이스에 인덱스를 생성해도 인덱스 사용 여부를 MySQL이 알아서 판단. 즉, 사용하지 않게 되면 공간만 낭비된 셈.

### 인덱스의 장점과 단점
#### 장점
- SELECT 문으로 검색하는 속도가 매우 빨라짐.
- 그 결과 컴퓨터의 부담이 줄어들어서 결국 전체 시스템의 성능이 향상됨.

#### 단점
- 인덱스도 공간을 차지해서 데이터베이스 안에 추가적인 공간이 필요. (대략 테이블의 10% 크기)
- 처음에 인덱스를 만드는 데 시간이 오래 걸릴 수 있음.
- SELECT가 아닌 데이터의 변경 작업(INSERT, UPDATE, DELETE)이 자주 일어나면 오히려 성능이 나빠질 수 있음.

## 인덱스의 종류
- 클러스터형, 보조 인덱스 2가지.
- 클러스터형 인덱스는 영어사전, 보조 인덱스는 찾아보기와 같음. 클러스터형 인덱스는 이미 알파벳 순서대로 정렬되어 있는 것.

### 자동으로 생성되는 인덱스
- 인덱스는 테이블의 열(컬럼) 단위에 생성되며, 하나의 열에는 하나의 인덱스를 생성 가능. (하나의 열에 여러 개, 여러 개를 묶어 하나의 인덱스 생성 가능. but, 자주 쓰이진 않음.)
- 간단한 테이블을 만들어 알아보자.
```mysql
create table table1 (
    col1 int primary key,
    col2 int,
    col3 int
);
show index from table1;
```
```text
+--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| table1 |          0 | PRIMARY  |            1 | col1        | A         |           0 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
+--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
1 row in set (0.00 sec)
```
- Key_name 은 PRIMARY로 기본 키로 설정해서 '자동으로 생성된 인덱스'라는 의미. 이것이 클러스터형 인덱스
- Column_name 이 col1으로 설정되었다는 것은 인덱스가 해당 열에 만들어 졌다는 의미.
- Non_Unique는 '고유하지 않다'로 중복 허용 여부. 0은 false, 1은 true.
- 고유 인덱스(Unique Index)는 인덱스의 값이 중복되지 않는다는 의미로 단순 인덱스(Non-Unique Index)는 중복 가능. 기본 키나 고유 키로 지정시 값이 중복되지 않으므로 고유 인덱스가
생성됨. 그 외 인덱스는 단순 인덱스로 생성됨.
- 기본 키와 더불어 고유 키도 인덱스가 자동으로 생성됨. 고유 키로 생성되는 인덱스는 보조 인덱스.
- 아래 col2, col3는 보조 인덱스
```mysql
create table table2 (
    col1 int primary key ,
    col2 int unique ,
    col3 int unique 
);
show index from table2;
```
```text
+--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| table2 |          0 | PRIMARY  |            1 | col1        | A         |           0 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| table2 |          0 | col2     |            1 | col2        | A         |           0 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
| table2 |          0 | col3     |            1 | col3        | A         |           0 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
+--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
3 rows in set (0.00 sec)
```

### 자동으로 정렬되는 클러스터형 인덱스
- 클러스터형 인덱스는 기본 키로 지정하면 자동 생성 및 테이블당 1개 생성. 특징을 알아보자.
- 영어사전처럼 정렬되어 저장됨.
```mysql
create table member
(
    mem_id      char(8),
    mem_name    varchar(10),
    mem_number  int,
    addr        char(2)
);
insert into member values('TWC', '트와이스', 9, '서울');
insert into member values('BLK', '블랙핑크', 4, '경남');
insert into member values('WMN', '여자친구', 6, '경기');
insert into member values('OMY', '오마이걸', 7, '서울');
select * from member;
```
```text
+--------+--------------+------------+--------+
| mem_id | mem_name     | mem_number | addr   |
+--------+--------------+------------+--------+
| TWC    | 트와이스     |          9 | 서울   |
| BLK    | 블랙핑크     |          4 | 경남   |
| WMN    | 여자친구     |          6 | 경기   |
| OMY    | 오마이걸     |          7 | 서울   |
+--------+--------------+------------+--------+
4 rows in set (0.00 sec)
```
- 결과는 입력한 순서대로 나옴. mem_id 열을 기본 키로 설정하고 내용을 확인해 보자.
```mysql
alter table member
    add constraint 
    primary key (mem_id);
select * from member;
```
```text
+--------+--------------+------------+--------+
| mem_id | mem_name     | mem_number | addr   |
+--------+--------------+------------+--------+
| BLK    | 블랙핑크     |          4 | 경남   |
| OMY    | 오마이걸     |          7 | 서울   |
| TWC    | 트와이스     |          9 | 서울   |
| WMN    | 여자친구     |          6 | 경기   |
+--------+--------------+------------+--------+
4 rows in set (0.00 sec)
```
- mem_id가 클러스터형 인덱스가 되어 기준이 되어 정렬됨.
- mem_id 열의 PK를 제거하고 mem_name 열을 PK로 지정해보자.
```mysql
alter table member drop primary key;
alter table member
    add constraint 
    primary key (mem_name);
select * from member;
```
```text
+--------+--------------+------------+--------+
| mem_id | mem_name     | mem_number | addr   |
+--------+--------------+------------+--------+
| BLK    | 블랙핑크     |          4 | 경남   |
| WMN    | 여자친구     |          6 | 경기   |
| OMY    | 오마이걸     |          7 | 서울   |
| TWC    | 트와이스     |          9 | 서울   |
+--------+--------------+------------+--------+
4 rows in set (0.00 sec)
```
- mem_name 열을 기준으로 다시 정렬됨.
- 추가로 데이터를 입력하면 알아서 기준에 맞춰 정렬됨.
```mysql
insert into member values('GRL', '소녀시대', 8, '서울');
select * from member;
```
```text
+--------+--------------+------------+--------+
| mem_id | mem_name     | mem_number | addr   |
+--------+--------------+------------+--------+
| BLK    | 블랙핑크     |          4 | 경남   |
| GRL    | 소녀시대     |          8 | 서울   |
| WMN    | 여자친구     |          6 | 경기   |
| OMY    | 오마이걸     |          7 | 서울   |
| TWC    | 트와이스     |          9 | 서울   |
+--------+--------------+------------+--------+
5 rows in set (0.00 sec)
```
- 기본 키 변경 시 주의할 점은 이미 데이터가 있는 상태에서 기본 키 지정시 시간이 엄청 오래 걸릴 수 있음. 또한, 위처럼 기본 키를 변경하는 것은 논리적으로 위험. (중복 관련 이슈)

### 정렬되지 않는 보조 인덱스
- 고유 키로 지정하면 보조 인덱스가 생성되고 보조 인덱스는 테이블에 여러 개 생성 가능. 즉, 고유 키를 테이블에 여러 개 지정 가능.
```mysql
create table member
(
    mem_id      char(8),
    mem_name    varchar(10),
    mem_number  int,
    addr        char(2)
);

insert into member values('TWC', '트와이스', 9, '서울');
insert into member values('BLK', '블랙핑크', 4, '경남');
insert into member values('WMN', '여자친구', 6, '경기');
insert into member values('OMY', '오마이걸', 7, '서울');
select * from member;
```
```text
+--------+--------------+------------+--------+
| mem_id | mem_name     | mem_number | addr   |
+--------+--------------+------------+--------+
| TWC    | 트와이스     |          9 | 서울   |
| BLK    | 블랙핑크     |          4 | 경남   |
| WMN    | 여자친구     |          6 | 경기   |
| OMY    | 오마이걸     |          7 | 서울   |
+--------+--------------+------------+--------+
4 rows in set (0.00 sec)
```
- 결과는 입력한 순서 그대로 나옴.
- 이제 mem_id 열을 고유 키로 설정하고 확인해보자. 데이터의 순서에는 변화가 없을 것임.
```mysql
alter table member
    add constraint 
    unique (mem_id);
select * from member;
```
```text
+--------+--------------+------------+--------+
| mem_id | mem_name     | mem_number | addr   |
+--------+--------------+------------+--------+
| TWC    | 트와이스     |          9 | 서울   |
| BLK    | 블랙핑크     |          4 | 경남   |
| WMN    | 여자친구     |          6 | 경기   |
| OMY    | 오마이걸     |          7 | 서울   |
+--------+--------------+------------+--------+
4 rows in set (0.00 sec)
```
- mem_name 열에 추가로 고유 키를 지정해보자. 결과 역시 동일할 것.
```mysql
alter table member
    add constraint 
    unique (mem_name);
select * from member;
```
```text
+--------+--------------+------------+--------+
| mem_id | mem_name     | mem_number | addr   |
+--------+--------------+------------+--------+
| TWC    | 트와이스     |          9 | 서울   |
| BLK    | 블랙핑크     |          4 | 경남   |
| WMN    | 여자친구     |          6 | 경기   |
| OMY    | 오마이걸     |          7 | 서울   |
+--------+--------------+------------+--------+
4 rows in set (0.01 sec)
```
- 데이터를 추가로 입력해도 맨 뒤에 추가가 될 것임.
```mysql
insert into member values('GRL', '소녀시대', 8, '서울');
select * from member;
```
```text
+--------+--------------+------------+--------+
| mem_id | mem_name     | mem_number | addr   |
+--------+--------------+------------+--------+
| TWC    | 트와이스     |          9 | 서울   |
| BLK    | 블랙핑크     |          4 | 경남   |
| WMN    | 여자친구     |          6 | 경기   |
| OMY    | 오마이걸     |          7 | 서울   |
| GRL    | 소녀시대     |          8 | 서울   |
+--------+--------------+------------+--------+
5 rows in set (0.00 sec)
```
- 보조 인덱스는 여러 개 만들 수 있음. 하지만 보조 인덱스는 데이터베이스의 공간을 차지해 전반적으로 시스템에 나쁜 영향을 미치게 됨. 꼭 필요한 열에만 사용 권장.

## 핵심 정리
- 클러스터형 인덱스는 영어사전처럼 내용이 이미 정렬되어 있는 인덱스로, 기본 키로 지정시 클러스터형 인덱스가 생성되고 해당 열로 자동 정렬됨.
- 보조 인덱스는 일반 책의 찾아보기와 같이 별도의 공간에 인덱스가 생성됨. 고유 키로 지정시 보조 인덱스가 생성되고 자동 정렬 X.
- 고유 인덱스는 값이 중복되지 않는 인덱스로 기본 키나 고유 키로 지정하면 값이 중복되지 않아 고유 인덱스가 자동으로 생성됨.
- 클러스터형 인덱스와 보조 인덱스 비교

| --      | 클러스터형 인덱스          | 보조 인덱스          |
|---------|--------------------|-----------------|
| 영문      | Clustered Index    | Secondary Index |
| 관련 제약조건 | 기본 키 (Primary Key) | 고유 키 (Unique)   |
| 테이블당 개수 | 1개                 | 여러 개            |
| 정렬      | 지정한 열로 정렬됨         | 정렬되지 않음         |
| 비유      | 영어 사전              | 일반 책의 찾아보기      |

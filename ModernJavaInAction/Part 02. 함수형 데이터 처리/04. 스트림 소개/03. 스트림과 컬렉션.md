# 4.3 스트림과 컬렉션
- 자바의 기존 컬렉션과 새로운 스트림 모두 연속된 요소 형식의 값을 저장하는 자료구조의 인터페이스를 제공함. 여기서 '연속된(sequenced)'이라는 표현은 순서와 상관없이 아무 값에나 접속하는 것이 아닌
순차적으로 값에 접근한다는 것을 의미함.
- 데이터를 언제 계산하느냐가 컬렉션과 스트림의 가장 큰 차이. 컬렉션은 현재 자료구조가 포함하는 모든 값을 메모리에 저장하는 자료구조. 즉, 컬렉션의 모든 요소는 컬렉션에 추가하기 전에 계산되어야 함.
  (컬렉션에 요소를 추가하거나 컬렉션의 요소를 삭제 가능. 이런 연산을 수행할 때마다 컬렉션의 모든 요소를 메모리에 저장해야 하며 컬렉션에 추가하려는 요소는 미리 계산되어야 함.)
- 반면 스트림은 이론적으로 요청할 때만 요소를 계산하는 고정된 자료구조. (스트림에 요소를 추가하거나 스트림에서 요소 제거 불가). 이러한 스트림의 특성은 프로그래밍에 큰 도움을 줌. 사용자가 요청하는
값만 스트림에서 추출한다는 것이 핵심. 사용자 입장에서는 이러한 변화를 알 수 없음. 결과적으로 스트림은 생산자(producer)와 소비자(consumer) 관계를 형성함. 또한 스트림은 게으르게 만들어지는
컬렉션과 같음. 즉, 사용자가 데이터를 요청할 때만 값을 계산함(경영학에서는 이를 요청 중심 제조(demand-driven manufacturing) 또는 즉석 제조(just-in-time manufacturing) 이라 부름).
- 반면 컬렉션은 적극적으로 생성됨(생산자 중심(supplier-driven): 팔기도 전에 창고를 가득 채움). 소수 예제에 이를 적용해 보면 컬렉션은 끝이 없는 모든 소수를 포함하려 할 것이므로 무한 루프를
돌면서 새로운 소수를 계산하고 추가하기를 반복할 것. 결국 소비자는 영원히 결과를 볼 수 없게 됨.
- 또 다른 예로 브라우저 인터넷 검샏. 구글에 검색어를 입력하면 그림을 포함한 모든 검색 결괴를 내려받을 때까지 기다리지 않아도 가장 비슷한 10, 20개 결과 요소를 포함하는 스트림을 얻을 수 있음
  (다음 10, 20개 결과를 확인할 수 있는 버튼과 함께). 소비자는 다음 10개 버튼을 누르면 발행자는 소비자의 요청을 받아 이를 계산한 다음 브라우저에 표시할 것임.

## 4.3.1 딱 한 번만 탐색할 수 있다
- 반복자와 마찬가지로 스트림도 한 번만 탐색 가능. 즉, 탐색된 스트림의 요소는 소비됨. 한 번 탐색한 요소를 재탐색하려면 초기 데이터 소스에서 새로운 스트림을 만들어야 함.
```java
public static void main(String[] args) {
    List<String> title = Arrays.asList("Java8", "In", "Action");
    Stream<String> s = title.stream();
    s.forEach(System.out::println);
    // s.forEach(System.out::println); // java.lang.IllegalStateException : 스트림이 이미 소비되었거나 닫힘.
}
```
- 스트림은 단 한 번만 소비할 수 있다는 점을 명심하자.
- 컬렉션과 스트림의 또 다른 차이점은 데이터 반복 처리 방법.

## 4.3.2 외부 반복과 내부 반복.
- 컬렉션 인터페이스를 사용하려면 사용자가 직접 요소를 반복해야 함 (예를 들면 for-each). 이를 외부 반복(external iteration)이라 함.
- 반면, 스트림 라이브러리는 (반복을 알아서 처리하고 결과 스트림값을 어딘가에 저장해주는) 내부 반복(internal iteration)을 사용함. 함수에 어떤 작업을 수행할지만 지정하면 모든 것이 알아서
처리됨. 다음 코드를 보자.
- 컬렉션 : for-each 루프를 이용하는 외부 반복.
```java
List<String> names = new ArrayList<>();
for (Dish dish : menu) { // 메뉴 리스트를 명시적으로 순차 반복.
    names.add(dish.getName()); // 이름을 추출해서 리스트에 추가함.
}
```
- for-each 구문은 반복자를 사용하는 불편함을 어느 정도 해결해줌. for-each를 이용하면 Iterator 객체를 이용하는 것보다 더 쉽게 컬렉션 반복 가능.
- 컬렉션 : 내부적으로 숨겨졌던 반복자를 사용한 외부 반복.
```java
List<String> names = new ArrayList<>();
Iterator<Dish> iterator = menu.iterator();
while (iterator.hasNext()) { // 명시적 반복
    Dish dish = iterator.next();
    names.add(dish.getName());
}
```
- 스트림 : 내부 반복
```java
List<String> names = menu.stream()
    .map(Dish::getName) // map 메서드를 getName 메서드로 파라미터화해서 요리명 추출함.
    .collect(Collectors.toList()); // 파이프라인을 실행함. 반복자는 필요 없음.
```
- 내부 반복과 외부 반복은 어떻게 다르고 어떤 이득을 줄까? 예제를 통해 살펴보자. 내가 딸 A에게 인형을 정리하라고 말하는 상황이다.
```text
나 : A야 장난감좀 정리하렴. 방바닥에 장난감이 있지?
A : 네, 공이 있어요.
나 : 좋아, 그럼 공을 상자에 담자. 또 어떤 장난감이 있지?
A : 인형이 있어요.
나 : 그럼 인형을 상자에 담자. 또 어떤 장난감이 있지?
A : 책이 있어요.
나 : 그럼 책을 상자에 담자. 또 어떤 장난감이 있지?
A : 아무것도 없어요
나 : 참 잘했어.
```
- 우리는 위 대화처럼 자바 컬렉션을 사용함. 컬렉션은 외부적으로 반복, 즉 명시적으로 컬렉션 항목을 하나씩 가져와서 처리함. 'A야, 바닥에 있는 모든 장난감을 상자에 담자'라고 말할 수 있으면 얼마나
좋을까?
- 내부 반복이 더 좋은 다른 두 가지 이유가 더 존재. 첫째로 A가 한 손에는 인형을 한 손에는 공을 동시에 들 수 있다는 점이고, 둘째로 먼저 모든 장난감을 상자 가까이 이동시킨 다음에 장난감을 상자에
넣을 수 있다는 점. 이렇듯 내부 반복을 이용하면 작업을 투명하게 병렬로 처리하거나 더 최적화된 다양한 순서로 처리 가능. 기존 자바에서처럼 컬렉션을 외부 반복으로 처리한다면 이와 같은 최적화를
달성하기 어려움.
- 하지만 내부 반복뿐 아니라 자바 8에서 스트림을 제공하는 더 다양한 이유가 존재. 스트림 라이브러리의 내부 반복은 데이터 표현과 하드웨어를 활용한 병렬성 구현을 자동으로 선택함. 반면, for-each를
이용하는 외부 반복에서는 병렬성을 스스로 관리해야 함(병렬성을 스스로 관리한다는 것은 병렬성을 포기하든지 아니면 synchronized로 시작하는 힘들고 긴 전쟁을 시작함을 의미).
- 자바 8에서는 컬렉션 인터페이스와 비슷하면서도 반복자가 없는 무엇이 절실했으며, 스트림이 탄생함.


- 스트림은 내부 반복을 사용하므로 반복 과정을 우리가 신경 쓰지 않아도 됨. 하지만 이와 같은 이점을 누리려면 (filter, map) 반복을 숨겨주는 연산 리스트가 미리 정의되어 있어야 함. 반복을 숨겨주는
대부분의 연산은 람다 표현식을 인수로 받으므로 동작 파라미터화를 화룡ㅇ 가능. 자바 언어 설계자들은 우리가 복잡한 데이터 처리 질의를 표현할 수 있도록 다양한 추가 연산을 제공함.
- 외부 반복을 내부 반복으로 리팩터링
```java
List<String> highCaloricDishes = new ArrayList<>();
Iterator<Dish> iter = menu.iterator();
while (iter.hasNext()) {
    Dish dish = iter.next();
    if (dish.getCalories() > 300) {
        highCaloricDishes.add(dish.getName());
    }
}

highCaloricDishes = menu.stream()
    .filter(dish -> dish.getCalories() > 300)
    .map(Dish::getName)
    .collect(Collectors.toList());
```

# 12-2. 동기화 기법
- 프로세스의 동기화는 어떻게 이루어질까? 어떻게 해야 임계 구역에 오직 하나의 프로세스만 진입하게 하고, 올바를 순서를 보장할 수 있을까?
- 동기화를 위한 대표적인 도구인 뮤텍스 락, 세마포, 모니터를 알아보자.

## 뮤텍스 락
- 임계 구역 문제와 이를 해결하기 위한 동기화를 옷 가게에서 탈의실을 이용하는 것에 비유하자. 탈의실에 옷을 입어볼 수 있는데,  손님들은 탈의실이라는 자원을 이용하고 탈의실 안에는 손님 한 명씩만 들어올 수 있어
손님은 '프로세스', 탈의실은 '임계 구역'이라고 할 수 있다.
- 밖에서 탈의실에 사람이 있는지 없는지는 열어 보고 자물쇠가 걸려 있다면 사람이 있다고 판단하고 기다린다. 자물쇠가 걸려 있지 않다면 탈의실을 이용하면 된다.
- 자물쇠 기능을 코드로 구현한 것이 뮤텍스 락(Mutex lock; MUTual EXclusion lock). 뮤텍스 락은 동시에 접근해서는 안 되는 자원에 동시에 접근하지 않도록 만드는 도구, 즉, 상호 배제를 위한 동기화 도구.
- 임계 구역에 진입하는 프로세스는 이 사실을 알리기 위해 뮤텍스 락을 이용해 임계 구역에 자물쇠를 걸어둘 수 있고, 다른 프로세스는 임계 구역이 잠겨 있다면 기다리고, 아니라면 임계 구역에 진입 가능.
- 뮤텍스 락의 매우 단순한 형태는 하나의 전역 변수와 두 개의 함수로 구현 가능.
  - 자물쇠 역할 : 프로세스들이 공유하는 전역 변수 lock
  - 임계 구역을 잠그는 역할 : acquire 함수
  - 임계 구역의 잠금을 해제하는 역할 : release 함수
- acquire 함수는 프로세스가 임계 구역에 진입 전에 호출하는 함수. 만일 임계 구역이 잠겨 있다면 열릴 때까지 (lock이 false가 될 때까지) 임계 구역을 반복적으로 확인하고, 열려 있다면 잠그는(lock을 true
로 바꾸는) 함수이다.
- release 함수는 임계 구역에서의 작업이 끝나고 호출하는 함수. 현재 잠긴 임계 구역을 열어 주는(lock을 false로 바꾸는) 함수라고 보면 된다.
```text
acquire() {
    while (lock == true)    // 만약 임계 구역이 잠겨 있다면
        ;                   // 임계 구역이 잠겨 있는지를 반복적으로 확인
    lock = true;            // 만약 임계 구역이 잠겨 있지 않다면 임계 구역 잠금
}

release() {
    lock = false;           // 임계 구역 작업이 끝났으니 잠금 해제
}
```
- acquire와 release 함수를 아래와 같이 임계 구역 전후로 호출함으로써 하나의 프로세스만 임계 구역에 진입 가능.
```text
acquire();      // 자물쇠 잠겨 있는지 확인, 잠겨 있지 않다면 잠그고 들어가기
// 임계구역       // 임계 구역에서의 작업 진행
release();      // 자물쇠 반환
```
- 생산자 소비자 문제 또한 아래와 같이 뮤텍스로 구현 가능
```text
acquire();
// '총합' 변수 접근
release();
```
- 이렇게 되면 프로세스는
  - 락을 획득할 수 없다면 (임계 구역에 진입할 수 없다면) 무작적 기다리고,
  - 락을 획득할 수 있다면 (임계 구역에 진입할 수 있다면) 임계 구역을 잠근 뒤 임계 구역에서의 작업을 진행하고,
  - 임계 구역에서 빠져나올 때엔 다시 임계 구역의 잠금을 해제함으로써
- 임계 구역을 보호할 수 있다.
- 참고로 acquire 함수를 보면 임계 구역이 잠겨 있을 경우 프로세스는 반복적으로 lock을 확인하는 것을 알 수 있다. 이는 마치 탈의실 문이 잠겨 있는지 쉴 새 없이 반복하며 확인해 보는 것과 같다. 이런 대기
방식을 바쁜 대기 (busy wait)라고 한다.
- C/C++, Python 등 일부 프로그래밍 언어에서는 사용자가 직접 acquire, release 함수를 구현하지 않도록 뮤텍스 락 기능을 제공한다. 실제 프로그래밍 언어가 제공하는 뮤텍스 락은 앞선 코드보다 훨씬 정교.

## 세마포
- 세마포 (semaphore)는 뮤텍스 락과 비슷하지만, 조금 더 일반화된 방식의 동기화 도구.
- 뮤텍스 락은 하나의 공유 자원에 접근하는 프로세스를 상정한 방식. 즉, 탈의실이 하나 있는 경우 가정. 하지만 탈의실이 여러 개 있는 상황처럼 공유 자원이 여러 개 있을 경우 (각 공유 자원에는 하나의 프로세스만
진입이 가능할지라도) 여러 개의 프로세스가 각각 공유 자원에 접근이 가능해야 한다.
- 예를 들어, 한 번에 하나의 프로세스만 이용가능한 프린터 세 대가 있을 때, 하나의 프린터를 사용할 수 있는 프로세스는 하나이지만, 총 세 개의 프로세스가 공유 자원(세 대의 프린터)을 이용 가능.
- 이처럼 세마포는 공유 자원이 여러 개 있는 상황에서도 적용이 가능한 동기화 도구.
- 엄밀히 말하면 세마포는 이진 세마포 (binary semaphore), 카운팅 세마포 (counting semaphore)가 있지만, 이진 세마포는 뮤텍스 락과 비슷한 개념이므로, 여기서 세마포는 카운팅 세마포.
- 세마포는 철도 신호기에서 유래된 단어로 신호기가 내려가 있을 때 '멈춤' 신호로 간주하고 잠시 멈추고 신호기가 올라와 있을 때는 '가도 좋다'는 신호로 간주하고 다시 움직이기 시작한다. 세마포는 이와 같이
'멈춤' 신호와 '가도 좋다'는 신호로서 임계 구역을 관리. 즉, 프로세스는 임계 구역 앞에서 멈춤 신호를 받으면 잠시 기다리고, 가도 좋다는 신호를 받으면 그제서야 임계 구역에 들어가게 된다.
- 세마포가 어떻게 구현되는 지 간략히 살펴보면, 뮤텍스 락과 비슷하게 하나의 변수와 두 개의 함수로 단순하게 구현 가능
  - 임계 구역에 진입할 수 있는 있는 프로세스의 개수 (사용 가능한 공유 자원의 개수)를 나타내는 전역 변수 S
  - 임계 구역에 들어가도 좋은지, 기다려야 할지를 알려주는 wait 함수
  - 임계 구역 앞에서 기다리는 프로세스에 '이제 가도 좋다'고 신호를 주는 signal 함수
- 뮤텍스 락을 사용할 때 임계 구역 진입 전후로 acquire(), release() 호출했듯이 세마포도 임계 구역 진입 전후로 wait()와 signal() 호출한다.
```text
wait()
// 임계 구역
signal()
```
- 변수 S는 임계 구역에 진입할 수 있는 프로세스의 개수, 혹은 사용 가능한 공유 자원의 개수이므로, 이를 토대로 생각해 보았을 때 wait 함수는 아래와 같이 만든다.
```text
wait() {
    while (S <= 0)  // 1
    ;               // 2
    S--;            // 3
}
```
1. 만일 임계 구역에 진입할 수 있는 프로세스 개수가 0 이하라면
2. 사용할 수 있는 자원이 있는지 반복적으로 확인하고,
3. 임계 구역에 진입할 수 있는 프로세스 개수가 하나 이상이면 S를 1 감소시키고 임계 구역 진입한다.
- signal 함수는 다음과 같이 만든다.
```text
signal() {
    S++; // 1
}
```
1. 임계 구역에서의 작업을 마친 뒤 S를 1 증가시킨다.
- 가령 세 개의 프로세스 P1, P2, P3가 두 개의 공유 자원에 P1, P2, P3 순서로 접근한다고 가정. 공유 자원이 두 개 있으니 변수 S는 2. 그렇다면 다음 순서로 실행된다.
1. 프로세스 P1 wait 호출. S는 현재 2이므로 S를 1 감소시키고 임계 구역 진입
2. 프로세스 P2 wait 호출. S는 현재 1이므로 S를 1 감소시키고 임계 구역 진입
3. 프로세스 P3 wait 호출. S는 현재 0이므로 무한히 반복하며 S 확인
4. 프로세스 P1 임계 구역 작업 종료, signal() 호출. S를 1 증가
5. 프로세스 P3 S가 1이 됨을 확인. S는 현재 1이므로, S를 1 감소시키고 임계 구역 진입
- 여기서 한 가지 문제가 있는데, 이 문제는 뮤텍스 락에도 해당하는 문제로 사용할 수 있는 공유 자원이 없는 경우 프로세스는 무작정 무한히 반복하며 S를 확인해야 한다. 이는 마치 탈의실 문이 잠겨 있는지 아닌지 
계속 반복해서 확인하는 것과 같다. 이렇게 바쁜 대기를 반복하며 확인할 시간에 CPU는 더 생산성 있는 작업을 할 수 있을 텐데, CPU 주기를 낭비한다는 점에서 손해.
- 그래서 실제로 세마포는 다른 더 좋은 방법 사용. wait 함수는 만일 사용할 수 있는 자원이 없을 경우 해당 프로세스 상태를 대기 상태로 만들고, 그 프로세스의 PCB를 세마포를 위한 대기 큐에 집어넣습니다. 그리고
다른 프로세스가 임계 구역에서의 작업이 끝나고 signal 함수를 호출하면 signal 함수는 대기 중인 프로세스를 대기 큐에서 제거하고, 프로세스 상태를 준비 상태로 변경한 뒤 준비 큐로 옮겨줌.
- 이를 간단한 코드로 나타내면 아래와 같다.
```text
wait() {
    S--;
    if (S < 0) {
        add this process to Queue;  // 1
        sleep();                    // 2
    }
}
```
1. 해당 프로세스 PCB를 대기 큐에 삽입한다.
2. 대기 상태로 접어든다.
```text
signal() {
    S++;
    if (S <= 0) {
        remove a process p from Queue   // 1
        wakeup(p)                       // 2
    }
}
```
1. 대기 큐에 있는 프로세스 p를 제거한다.
2. 프로세스 p를 대기 상태에서 준비 상태로 만든다.
- 예시를 통해 알아보자. 공유 자원 두 개, 접근하려는 프로세스는 P1, P2, P3 세 개이고, P1, P2, P3 순서로 임계 구역에 접근한다고 가정해보자. 공유 자원 2개이므로 S는 2이다.

1. 프로세스 P1 wait 호출. S를 1 감소시키면 S는 1이므로 임계 구역 진입
2. 프로세스 P2 wait 호출. S를 1 감소시키면 S는 0이므로 임계 구역 진입
3. 프로세스 P3 wait 호출. S를 1 감소시키면 S는 -1이므로 본인의 PCB를 대기 큐에 넣고 대기 상태로 전환
4. 프로세스 P1 임계 구역 작업 종료, signal() 호출. S가 1 증가하면 0이므로 대기 상태였던 P3를 대기 큐에서 꺼내 준비 큐로 옮겨줌
5. 깨어난 프로세스 P3 임계 구역 진입
6. 프로세스 P2 임계 구역 작업 종료, signal() 호출. S가 1 증가하면 1
7. 프로세스 P3 임계 구역 작업 종료, signal() 호출. S가 1 증가하면 2

- 변수 S가 무엇을 의미하는지, wait, signal 함수의 코드가 무엇을 의미하는지가 중요.
- 앞에서 동기화의 정의에서 '동시에 접근해서는 안되는 자원에 동시에 접근하지 않도록 제어하는 것'도 동기화(상호 배제를 위한 동기화) 이지만, '특정 조건이 만족되어야만 실행할 수 있는 상황에서 올바른 순서대로 
실행하게 하는 것' 또한 동기화(실행 순서 제어를 위한 동기화)라고 했다. 
- 지금까지의 내용은 세마포를 이용한 상호 배제를 위한 동기화 기법이었다면 다음으로 세마포를 이용해 프로세스의 순서를 제어하는 방법에 대해 알아보자. 세마포를 이용해 동시에 실행되는 프로세스의 실행 순서도
원하는 대로 제어 가능.
- 방법은 간단하다. 세마포의 변수 S를 0으로 두고 먼저 실행할 프로세스(P1) 뒤에 signal 함수, 다음에 실행할 프로세스(P2) 앞에 wait 함수를 붙이면 된다.
- 이 경우, P1이 먼저 실행 되면 P1이 임계 구역에 먼저 진입하는 것은 자명한 일. P2가 먼저 실행되더라도 P2는 wait 함수를 만나므로 P1이 임계 구역에 진입한다. 그리고 P1이 임계 구역의 실행을 끝내고
signal을 호출하면 그제서야 P2가 임계 구역에 진입한다. 즉, P1이 먼저 실행되든 P2가 먼저 실행되든 반드시 P1, P2 순서대로 실행됨

## 모니터
- 세마포는 그 자체로 매우 훌륭한 프로세스 동기화 도구이지만, 사용하기가 조금 불편한 면이 있다. 매번 임계 구역에 앞뒤로 일일이 wait, signal 함수를 명시하는 것은 번거롭기 때문. 더군나나 잘못된 코드
작성으로 예기치 못한 결과를 얻을 수 있다.
- 이에 최근 등장한 동기화 도구가 모니터(monitor)이다. 모니터는 세마포에 비하면 사용자가 사용하기에 훨씬 편리한 도구. 모니터는 공유 자원과 공유 자원에 접근하기 위한 인터페이스(통로)를 묶어 관리.
그리고 프로세스는 반드시 인터페이스를 통해서만 공유 자원에 접근하도록 함.
- 이를 위해 모니터를 통해 공유 자원에 접근하고자 하는 프로세스를 큐에 삽입하고, 큐에 삽입된 순서대로 하나씩 공유 자원을 이용하도록 한다. 즉, 모니터는 공유 자원을 다루는 인터페이스에 접근하기 위한 큐
  (모니터에 진입하기 위한 큐)를 만들고, 모니터 안에 항상 하나의 프로세스만 들어오도록 하여 상호 배제를 위한 동기화를 제공.
- 이 밖에도 모니터는 세마포와 마찬가지로 실행 순서 제어를 위한 동기화도 제공. 특정 조건을 바탕으로 프로세스를 실행하고 일시 중단하기 위해 모니터는 조건 변수(conditional variable)을 사용하는데,
조건 변수는 프로세스나 스레드의 실행 순서를 제어하기 위해 사용하는 특별한 변수이다.
- 조건 변수로는 wait와 signal 연산을 수행할 수 있다. 우선 wait는 호출한 프로세스의 상태를 대기 상태로 전환하고 일시적으로 조건 변수에 대한 대기 큐에 삽입하는 연산. 여기서 헷갈리면 안 되는 점은 모니터에
진입하기 위해 삽입되는 큐(상호 배제를 위한 큐)와 wait가 호출되어 실행이 중단된 프로세스들이 삽입되는 큐(조건 변수에 대한 큐)는 다르다는 점이다. 전자는 모니터에 한 번에 하나의 프로셋만 진입하도록 하기 위해
만들어진 큐, 후자는 모니터에 이미 진입한 프로세스의 실행 조건이 만족될 때까지 잠시 실행이 중단되어 기다리기 위해 만들어진 큐이다.
- 모니터에 진입한 어떤 프로세스가 x.wait()를 통해 조건 변수 x에 대한 wait를 호출했다고 가정하자. 그 프로세스는 조건 변수 ㅌ에 대한 큐에 삽입되므로 모니터는 다시 비게 된다. 그렇기에 다른 프로세스가
모니터 안에 들어올 수 있다.
- wait 연산으로 일시 중지된 프로세스는 다른 프로세스의 signal 연산을 통해 실행이 재개될 수 있다. 즉, signal은 wait를 호출해 큐에 삽입된 프로세스의 실행을 재개하는 연산이다. 가령 어떤 프로세스가 
x.signal()을 통해 조건 변수 x에 대한 signal을 호출했따고 가정해 보자. 이를 통해 조건 변수 x에 대해 대기 상태에 있던 프로세스가 깨어나 모니터 안으로 다시 들어올 수 있게 된다.
- 모니터 안에는 하나의 프로세스만이 있을 수 있으므로 wait 를 호출했던 프로세스는 signal을 호출한 프로세스가 모니터를 떠난 뒤에 실행되거나, signal을 호출한 프로세스의 실행을 일시 중단하고 자신이 실행된
뒤 다시 signal을 호출한 프로세스의 수행을 재개한다. 중요한 점은 모니터는 조건 변수를 이용해 아래와 같은 프로세스 실행 순서 제어를 위한 동기화를 제공한다는 사실이다.
1. 특정 프로세스가 아직 실행될 조건이 되지 않았을 때에는 wait를 통해 실행을 중단한다.
2. 특정 프로세스가 실행될 조건이 충족되었을 때에는 signal을 통해 실행을 재개한다.

## 키워드 정리
- 뮤텍스 락은 임계 구역을 잠금으로써 프로세스 간의 상호 배제를 이룬다.
- 세마포는 공유 자원이 여러 개 있는 임계 구역 문제도 해결할 수 있는 동기화 도구.
- 모니터는 세마포에 비해 사용자가 사용하기 편리한 동기화 도구로 조건 변수를 사용.

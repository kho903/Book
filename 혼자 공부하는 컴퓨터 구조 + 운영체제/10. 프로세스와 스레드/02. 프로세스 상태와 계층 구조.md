# 10.2 프로세스 상태와 계층 구조
- 프로세스는 모두 저마다의 상태가 있다. 운영체제는 프로세스의 상태는 PCB에 기록하여 관리함. 그리고 많은 운영체제는 이처럼 동시에 실행되는 수많은 프로세스를 계층적으로 관리한다.

## 프로세스 상태
- 컴퓨터를 사용할 때 여러 프로세스들이 빠르게 번갈아 가면서 실행된다. 그 과정에서 하나의 프로세스는 여러 상태를 거치며 실행된다.
- 그리고 운영체제는 프로새스의 상태를 PCB를 통해 인식하고 관리한다. 프로세스의 상태를 표현하는 방식은 운영체제마다 조금씩 차이가 있지만, 프로세스가 가질 수 있는 대표적인 상태는 다음과 같다.

### 생성 상태
- 프로세스를 생성 중인 상태를 생성 상태(new)
- 이제 막 메모리에 적재되어 PCB를 할당받은 상태.
- 생성 상태를 거쳐 실행할 준비가 완료된 프로세스는 곧바로 실행되지 않고 준비 상태가 되어 CPU의 할당을 기다림.

### 준비 상태
- 준비 상태(ready)는 당장이라도 CPU를 할당받아 실행할 수 있지만, 아직 자신의 차례가 아니기에 기다리고 있는 상태.
- 준비 상태 프로세스는 차례가 되면 CPU를 할당받아 실행 상태가 됨. 이렇게 전환되는 것을 디스패치(dispatch)라고 함.

### 실행 상태
- 실행 상태(running)는 CPU를 할당받아 실행 중인 상태.
- 실행 상태인 프로세스는 할당된 일정 시간 동안만 CPU 사용 가능.
- 이 때 프로세스가 할당된 시간을 모두 사용(타이머 인터럽트 발생)시, 다시 준비 상태가 되고, 실행 도중 입출력장치를 사용하여 입출력 장치의 작업이 끝날 때까지 기다려야 한다면 대기상태가 됨.

### 대기 상태
- 프로세스는 실행 도중 입출력장치를 사용하는 경우가 있다.
- 입출력 작업은 CPU에 비해 처리 속도가 느리기에, 입출력 작업을 요청한 프로세스는 입출력장치가 입출력을 끝낼 때까지(입출력 완료 인터럽트를 받을 때까지) 기다려야 함.
- 이렇게 입출력장치의 작업을 기다리는 상태를 대기상태(blocked)라고 함. 입출력 작업이 완료되면 해당 프로세스는 다시 준비 상태로 CPU 할당을 기다림.

### 종료 상태
- 종료 상태(terminated)는 프로세스가 종료된 상태.
- 프로세스가 종료되면 운영체제는 PCB와 프로세스가 사용한 메모리를 정리.


- 이처럼 컴퓨터 내의 여러 프로세스는 생성, 준비, 실행, 대기, 종료 상태를 거치며 실행됨. 운영체제는 이 상태를 PCB에 기록하며 프로세스들을 관리하는 것.
> 대기 상태의 일반적인 정의 : 프로세스가 대기 상태가 되는 이유에 입출력 작업만 있는 것은 아님. 조금 더 일반적으로 표현하면 특정 이벤트가 일어나길 기다릴 때 프로세스는 대기 상태가 됨.
> 다만, 프로세스가 대기 상태가 되는 대부분의 원인이 입출력 작업이기 때문에 '프로세스가 입출력 작업을 하면 대기 상태가 된다'고 생각해도 무방.

## 프로세스 계층 구조
- 프로세스는 실행 도중 시스템 호출로 다른 프로세스 생성 가능. 새 프로세스를 생성한 프로세스가 부모 프로세스(parent process), 부모 프로세스에 의해 생성된 프로세스를 자식 프로세스(child
process)라고 함.
- 둘은 엄연히 다른 프로세스로, 다른 PID를 가지는데, 일부 운영체제에서는 자식 프로세스의 PCB에 PPID(Parent PID)를 기록하기도 함.
- 부모 프로세스로부터 생성된 자식 프로세스는 또다른 자식 프로세스 생성 가능. 그 자식도 또 다른 자식 프로세스 생성 가능. 많은 운영체제는 이처럼 프로세스가 프로세스를 낳는 계층적인 구조로써
프로세스들을 관리. 컴퓨터가 부팅될 때 실행되는 최초의 프로세스가 자식 프로세스들을 생성하고, 생성된 자식 프로세스들이 새로운 프로세스들을 낳는 형식으로 여러 프로세스가 동시에 실행.
- 이 과정을 도표로 그리면 트리구조, 이를 프로세스 계층 구조라고 함.
- 예를 들어 사용자가 컴퓨터를 켜고 로그인 창으로 로그인 후 bash 셸(사용자 인터페이스)로 Vim 을 실행했다고 가정하자.
  1. 사용자가 컴퓨터를 켠 순간 생성된 최초 프로세스는 로그인을 담당하는 프로세스를 자식 프로세스로 생성
  2. 로그인 프로세스는 사용자 인터페이스(bash 셸) 프로세스를 자식 프로세스로 생성
  3. 사용자 인터페이스 프로세스는 Vim 프로세스를 생성한 셈
- 데몬이나 서비스 또한 최초 프로세스의 자식 프로세스
- 최초 프로세스는 유닉스에서는 init, 리눅스에서는 systemd, macOS에서는 launchd 이다. pstree 명령어로 확인 가능

## 프로세스 생성 기법
- 부모 프로세스를 통해 생성된 자식 프로세스들은 복제와 옷 갈아입기를 통해 실행됨.
- 조금 더 정확하게, 부모 프로세스는 fork로 자신의 복사본을 자식 프로세스로 생성해내고, 만들어진 복사본(자식 프로세스)은 exec로 자신의 메모리 공간을 다른 프로그램으로 교체한다.
- fork, exec는 시스템 호출. fork는 자기 자신 프로세스의 복사본을 만드는 시스템 호출. 자식 프로세스는 부모 프로세스의 복사본이기 때문에 부모 프로세스의 자원들, 이를테면 메모리의 내용,
열린 파일 목록 등이 자식 프로세스에 상속됨.
- fork로 복사본이 된 자식 프로세스는 exec 시스템 호출로 새로운 프로그램으로 전환됨. exec는 자신의 메모리 공간을 새로운 프로그램으로 덮어쓰는 시스템 호출. 다시 말해 새로운 프로그램 내용으로
전환하여 실행하는 시스템 호출.
- 메모리 공간에 새로운 프로그램 내용이 덮어 써진다는 점에서 이는 자식 프로세스가 새로운 옷으로 갈아입었다고 볼 수 있다. exec 호출시, 코드 영역과 데이터 영역의 내용이 실행할 프로그램의 내용으로
바뀌고 나머지 영역은 초기화 됨.
- 정리하면, 부모가 자삭 프로세스를 실행하며 프로세스 계층 구조를 이루는 과정은 fork와 exec가 반복되는 과정이라 볼 수 있다.
- 부모 프로세스가 자식 프로세스를 fork한 뒤, 자식 프로세스 누구도 exec 하지 않는 경우, 부모 프로세스와 자식 프로세스는 같은 코드를 병행하여 실행하는 프로세스가 됨.

## 키워드 정리
- 프로세스 상태에는 생성, 준비, 실행, 대기, 종료가 있다.
- 프로세스가 다른 프로세스를 생성한 경우 프로세스를 생성한 프로세스를 부모 프로세스, 생성된 프로세스를 자식 프로세스라고 부른다.
- 많은 운영체제는 프로세스가 프로세스를 낳는 프로세스 계층 구조로 프로세스들을 관리한다.


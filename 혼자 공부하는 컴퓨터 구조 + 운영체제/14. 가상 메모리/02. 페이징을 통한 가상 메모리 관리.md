# 14-02. 페이징을 통한 가상 메모리 관리
- 프로세스를 메모리에 연속적으로 할당하는 방식은 외부 단편화와 물리 메모리보다 큰 프로세스를 실행할 수 없다는 문제가 있다.
- 가상 메모리(virtual memory)는 실행하고자 하는 프로그램을 일부만 메모리에 적재해 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술.
- 이를 가능케 하는 가상 메모리 관리 기법에는 크게 페이징과 세그멘테이션이 있다.

## 페이징이란
- 연속 메모리 할당 방식에서 외부 단편화가 생긴 근본적인 이유는 각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되었기 때문.
- 만일 메모리와 프로세스를 일정한 단위로 자르고, 이를 메모리에 불연속적으로도 할당할 수만 있다면 외부 단편화는 발생하지 않는다. 이것이 페이징(paging)이다.
- 페이징은 프로세스의 논리 주소 공간을 페이지(page)라는 일정한 단위로 자르고, 메모리 물리 주소 공간을 프레임(frame)이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤 페이지를 프레임에
할당하는 가상 메모리 기법.
- 페이징에서도 스와핑을 사용할 수 있는데, 페이징을 사용하는 시스템에서는 프로세스 전체가 스왑 아웃/인되는 것이 아닌 페이지 단위로 스왑 아웃/인 된다. 즉, 메모리에 적재될 필요가 없는 페이지들은
보조기억장치로 스왑 아웃, 실행에 필요한 페이지들은 메모리로 스왑 인되는 것.
- 페이징 시스템에서의 스왑 아웃은 페이지 아웃(page out), 스왑 인은 페이지 인(page in)이라고도 부른다.
- 이는 다르게 말하면 한 프로세스 실행 위해 프로세스 전체가 메모리 전체에 적재될 필요가 없다는 말이다. 이와 같은 방식으로 물리 메모리보다 더 큰 프로세스 실행 가능.

## 페이지 테이블
- 여기서 문제는 프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU 입장에서 이를 순차적으로 실행 불가. 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 모두 알고 있기란 어렵기 
때문. 즉, 프로세스가 메모리에 불연속적으로 배치되면 CPU 입장에서 '다음에 실행할 명령어 위치'를 찾기가 어렵.
- 이를 해결하기 위해 페이징 시스템은 비록 (실제 메모리 내의 주소인) 물리 주소에 불연속적으로 배치되더라고 (CPU가 바라보는 주소인) 논리 주소에는 연속적으로 배치되도록 페이지 테이블(page table)
을 이용.
- 페이지 테이블은 페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표. 페이지 테이블은 현재 어떤 페이지가 어떤 프레임에 할당되었는지 알려줌.
- 프로세스마다 각자의 프로세스 테이블이 있다.
- 비록 물리 주소상에서는 프로세스들이 분산되어 저장되어 있더라도 CPU 입장에서 바라본 논리 주소는 연속적으로 보일 수 있다. 즉 프로세스들이 메모리에 분산되어 저장되어 있더라도 CPU는 논리 주소를
그저 순차적으로 실행하면 된다.
  - 페이징은 외부 단편화 문제를 해결 가능, but 내부 단편화 문제 야기할 수 있다. 페이징은 프로세스의 논리 주소 공간을 페이지라는 일정한 크기 단위로 자른다고 했는데, 모든 프로세스가 페이지 크기에
    딱맞게 잘리는 것은 아니다. 예를 들어 페이지 크기가 10KB, 프로세스 크기가 108KB일때, 마지막 페이지는 2KB만큼의 크기가 남는데, 이러한 메모리 낭비를 내부 단편화라고 한다. 내부 단편화는
    하나의 페이지 크기보다 작은 크기로 발생. 그래서 하나의 페이지 크기가 작다면 발생하는 내부 단편화의 크기는 작아질 것. 하지만 하나의 페이지 크기를 너무 작게 설정하면 그만큼 페이지 테이블의
    크기도 커지기 때문에 페이지 테이블이 차지하는 공간이 낭비됨. 그렇기에 내부 단편화를 적당히 방지하면서 너무 작지 않은 페이지 테이블이 만들어질 수 있도록 페이지 크기 조정이 중요.
- 프로세스마다 각자의 프로세스 테이블을 가지고 있고 각 프로세스의 페이지 테이블들은 메모리에 적재됨. 그리고 CPU 내의 페이지 테이블 베이스 레지스터(PTBR;Page Table Base Register)는
각 프로세스의 페이지 테이블이 적재된 주소를 가리키고 있다.
- 예를 들어 프로세스 A 실행시 PTBR은 프로세스 A의 페이지 테이블을 가리키고, CPU는 프로세스 A의 페이지 테이블을 통해 프로세스 A의 페이지가 적재된 프레임을 알 수 있다.
- 그런데 이렇게 페이지 테이블을 메모리에 두면 문제가 있다. 메모리 접근 시간이 두 배로 늘어난다는 점. 메모리에 있는 페이지 테이블을 보기 위해 한 번, 그렇게 알게 된 프레임에 접근하기 위해 한 번.
이렇게 총 두 번의 메모리 접근이 필요.
- 이와 같은 문제 해결 위해 CPU 곁에 (일반적으로 MMU 내에) TLB (Translation Lookaside Buffer)라는 페이지 테이블의 캐시 메모리를 둔다. TLB는 페이지 테이블의 캐시로 페이지 테이블의
일부 내용을 저장한다. 참조 지역성에 근거해 주로 최근에 사용된 페이지 위주로 가져와 저장.
- CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있으면 TLB 히트라고 하고, 이 경우 페이지가 적재된 프레임을 알기 위해 메모리에 접근할 필요 없음. 그렇기에 메모리 접근을 한 번만 하면 됨.
- 하지만 만일 페이지 번호가 TLB에 없을 경우 어쩔 수 없이 페이지가 적재된 프레임을 알기 위해 메모리 내의 페이지 테이블에 접근하는 수밖에 없고, 이를 TLB 미스라고 한다.

## 페이징에서의 주소 변환
- 하나의 페이지 혹은 프레임은 여러 주소를 포괄하고 있어 특정 주소에 접근하려면 아래와 같은 두 가지 정보가 필요.
  - 어떤 페이지 혹은 프레임에 접근하고 싶은지
  - 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지
- 그렇기에 페이징 시스템에서는 모든 논리 주소가 기본적으로 페이지 번호(page number)와 변위(offset)로 이루어져 있다. 가령 CPU가 32 비트 주소를 내보냈다면 이 중 N비트는 페이지 번호,
32-N비트는 변위, 이런식으로 된다.
- 페이지 번호는 말 그대로 접근하고자 하는 페이지 번호. 페이지 테이블에서 해당 페이지 번호를 찾으면 페이지가 어떤 프레임에 할당되었는지를 알 수 있다. 변위는 접근하려는 주소가 프레임의 시작
번지로부터 얼만큼 알기 위한 정보로, 논리 주소 <페이지 번호, 변위>는 페이지 테이블을 통해 물리 주소 <프레임 번호, 변위>로 변환됨.

## 페이지 테이블 엔트리
- 페이지 테이블의 각 엔트리, 다시 말해 페이지 테이블의 각 행들을 페이지 테이블 엔트리 (PTE;Page Table Entry)라고 한다.
- 지금까지는 페이지 테이블 엔트리에 담기는 정보로 페이지 번호, 프레임 번호만을 설명했지만, 이외에도 유효 비트, 보호 비트, 참조 비트, 수정 비트가 있다.

### 유효 비트 (valid bit)
- 유효 비트는 현재 해당 페이지에 접근 가능한지 여부를 알려준다. 페이지 테이블 엔트리에서 프레임 번호 다음으로 중요한 정보이다. 페이징에서도 스와핑을 사용할 수 있으므로, 일반적으로 프로세스를
이루는 모든 페이지가 메모리에 있지 않아 보조기억장치에 있는 경우가 많다. 유효 비트는 현재 페이지가 메모리에 적재 되어 있다면 1, 아니면 0이 된다.
- 만일 0인 메모리에 적재되어 있지 않은 페이지로 접근시 페이지 폴트(page fault)라는 예외(Exception)이 발생한다. 
- CPU가 페이지 폴트를 처리하는 과정은 하드웨어 인터럽트를 처리하는 과정과 유사.
1. CPU는 기존의 작업 내역을 백업
2. 페이지 폴트 처리 루틴 실행
3. 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트 1로 변경
4. 페이지 폴트를 처리했다면 이제 CPU는 해당 페이지에 접근 가능

### 보호 비트 (protection bit)
- 보호 비트는 페이지 보호 기능을 위해 존재하는 비트. 
- 해당 페이지가 읽고 쓰기가 모두 가능한 페이지인지, 혹은 읽기만 가능한 페이지인지를 나타낼 수 있다.
- 비트가 0이면 읽기만 가능한 페이지. 1일 경우 읽고 쓰기가 모두 가능한 페이지.
- 읽기 전용 페이지에 쓰기를 시도하면 운영체제가 이를 막아줌.
- 보호 비트는 세 개의 비트로 조금 더 복잡하게 구현 가능. 읽기(Read)를 나타내는 r, 쓰기(Write)를 나타내는 w, 실행(eXecute)을 나타내는 x의 조합으로 읽기, 쓰기, 실행하기 권한의 조합을
나타낼 수도 있다. 가령 보호 비트가 100으로 설정된 페이지의 경우 r은 1, w와 x는 0으로 읽기만 가능하다.

### 참조 비트 (reference bit)
- 참조 비트는 CPU가 이 페이지에 접근한 적이 있는지 여부를 나타낸다. 적재 이후 CPU가 읽거나 쓴 페이지는 참조 비트가 1로 세팅되고, 적재 이후 한 번도 읽거나 쓴 적이 없는 페이지는 0으로 유지됨.

### 수정 비트 (modified bit)
- 수정 비트는 해당 페이지에 데이터를 쓴 적이 있는지 없는지 수정 여부를 알려줌. 더티 비트(dirty bit)라고도 부름. 이 비트가 1이면 변경된 적이 있는 페이지, 0이면 변경된 적이 없는 페이지
  (한 번도 접근한 적이 없거나 읽기만 했던 페이지)를 나타냄.
- 수정 비트는 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 해야 하는지, 할 필요가 없는지를 판단하기 위해 존재.
- CPU는 메모리를 읽기도 하지만 값을 쓰기도 한다. CPU가 한 번도 접근하지 않았거나 읽기만 한 페이지의 경우 보조기억장치에 저장된 해당 페이지의 내용과 메모리에 저장된 페이지 내용은 서로 같은 값을
가지고 있어 한 번도 수정된 적이 없는 페이지가 스왑 아웃될 셩우 아무런 추가 작업 없이 새로 적재된 페이지로 덮어쓰기만 하면 된다. 어차피 똑같은 페이지가 보조기억장치에 있기 떄문.
- 하지만 CPU가 쓰기 작업을 수행한 페이지(수정 비트가 1)의 경우 보조기억장치에 저장된 페이지의 내용과 메모리에 저장된 페이지의 내용은 서로 다른 값을 갖게 된다. 이 경우 페이지가 스왑 아웃될
경우 변경된 값을 보조기억장치에 기록하는 작업이 추가되어야 함. 이 작업이 필요한 페이지인지 판단을 위해 페이지 테이블 엔트리에 수정 비트를 두는 것.

## 페이징의 이점 - 쓰기 시 복사 (copy on write)
- 외부 단편화 문제 해결 외에도 페이징이 제공하는 이점은 다양하다. 대표적으로 프로세스 간에 페이지를 공유할 수 있다는 점. 프로세스 간 페이지를 공유하는 사례로는 공유 라이브러리 등 다양하지만,
대표적인 예시로 쓰기 시 복사(copy on write)이 있다.
- 앞에서 `프로세스를 fork하여 동일한 프로세스 두 개가 복제되면 코드 및 데이터 영역을 비롯한 모든 자원이 복제되어 메모리에 적재된다.` 그리고, `프로세스를 통째로 메모리에 중복 저장하지 않으면서
프로세스끼리 자원을 공유하지 않는 방법도 있다`라고 했다.
- 유닉스, 리눅스같은 운영체제에서 fork 시스템 호출시 부모 프로세스의 복사본이 자식 프로세스로서 만들어진다. '프로세스 간에는 기본적으로 자원을 공유하지 않는다'는 프로세스의 전통적인 개념에
입각하면 새롭게 생성된 자식 프로세스의 코드 및 데이터 영역은 부모 프로세스가 적재된 메모리 공간과는 전혀 다른 메모리 공간에 생성된다. 즉, 부모 프로세스의 메모리 영역이 다른 영역에 자식 
프로세스로서 복제되고, 각 프로세스의 페이지 테이블은 자신의 고유한 페이지가 할당된 프레임을 가리킨다. 하지만 이 복사 작업은 프로세스 생성 시간을 늦출 뿐만 아니라 불필요한 메모리 낭비 야기.
- 반면 쓰기 시 복사에서는 부모 프로세스와 동일한 자식 프로세스가 생성되면 자식 프로세스로 하여금 부모 프로세스와 동일한 프레임을 가리킨다. 이로써 굳이 부모 프로세스의 메모리 공간을 복사하지
않고도 동일한 코드 및 데이터 영역을 가리킬 수 있다. 만일 부모 프로세스와 자식 프로세스가 메모리에 어떠한 데이터도 쓰지 않고 그저 읽기 작업만 이어 나간다면 이 상태가 지속됨.
- 그런데 프로세스 간에는 자원을 공유하지 않는다. 부모 프로세스 혹은 자식 프로세스 둘 중 하나가 페이지에 쓰기 작업을 하면 그 순간 해당 페이지가 별도의 공간으로 복제됨. 각 프로세스는 자신이
고유한 페이지가 할당된 프레임을 가리킨다. 이것이 쓰기 시 복사이다. 이러한 쓰기 시 복사를 통해 프로세스 생성 시간을 줄이는 것은 물론 메모리 공간 절약도 가능.

## 계층적 페이징 (hierarchical paging)
- 페이지 테이블의 크기는 생각보다 작지 않다. 프로세스의 크기가 커지면 자연히 프로세스 테이블의 크기도 커져 프로세스를 이루는 모든 페이지 테이블 엔트리를 메모리에 두는 것은 큰 메모리 낭비.
- 이에 프로세스를 이루는 모든 페이지 테이블 엔트리를 항상 메모리에 유지하지 않을 수 있는 방법이 계층적 페이징이다.
- 계층적 페이징은 페이지 테이블을 페이징해 여러 단계의 페이지를 두는 방식으로 다단계 페이지 테이블(multilevel page table) 기법이라고도 부른다. 프로세스의 페이지 테이블을 여러 개의 페이지로
자르고, 바깥족에 페이지 테이블을 하나 더 두어 잘린 페이지 테이블의 페이지들을 가리키게 하는 방식. 
- 예를 들어, 한 프로세스의 페이지 테이블이 계층적 페이징 기법을 사용하지 않으면 이 프로세스 테이블은 전체가 메모리에 있어야 한다. 이 페이지 테이블을 여러 개의 페이지로 쪼개고, 이 페이지들을
가리키는 페이지 테이블을 두는 방식이 계층적 페이징이다.
- 페이지 테이블을 계층적으로 구성하면 모든 페이지 테이블을 항상 메모리에 유지할 필요가 없다. 페이지 테이블들 중 몇 개는 보조기억장치에 있어도 무방하며, 추후 해당 페이지 테이블을 참조해야
할 때가 있으면 그때 메모리에 적재하면 그만이다. 막대한 크기의 페이지 테이블로 인해 낭비되는 공간을 줄일 수 있다. (다만, CPU와 가장 가까이 위치한 페이지 테이블은 메모리에 유지해야 한다.)
- 계층적 페이징을 사용하는 경우 CPU가 발생하는 논리 주소도 달라지는데, 바깥 페이지 번호, 안쪽 페이지 번호, 변위로 이루어진다. 바깥 페이지 번호에 해당하는 항목은 CPU와 근접한 곳에 위치한
  (바깥에 위치한) 페이지 테이블 엔트리를 가리키고, 안쪽 페이지 번호는 첫 번째 페이지 테이블 바깥에 위치한 두 번째 페이지 테이블, 즉 페이지 테이블의 페이지 번호를 가리킨다.
- 이러한 논리 주소를 토대로 주소 변환은 다음과 같이 이루어진다.
1. 바깥 페이지 번호를 통해 페이지 테이블의 페이지 찾기
2. 페이지 테이블의 페이지를 통해 프레임 번호를 찾고 변위를 더함으로서 물리 주소 얻기
- 페이지 테이블의 계층은 세 개, 네 개, 그 이상의 계층으로도 구성될 수 있지만, 페이지 테이블의 계층이 늘어날수록 페이지 폴트가 발생했을 경우 메모리 참조 횟수가 많아지므로 계층이 많다고 해서
반드시 좋다고 할 수는 없다.

## 키워드 정리
- 페이징은 물리 주소 공간을 프레임 단위로 자르고 프로세스의 논리 주소 공간을 페이지 단위로 자른 뒤 각 페이지를 프레임에 할당하는 가상 메모리 관리 기법
- 페이지 테이블을 통해 페이지가 적재된 프레임을 찾을 수 있다. 페이지 테이블에는 페이지 번호와 프레임 번호뿐 아니라 유효 비트, 보호 비트, 접근 비트, 수정 비트 등이 있다.
- PTBR은 각 프로세스의 페이지 테이블이 적재된 주소를 가리킨다.
- TLB는 페이지 테이블의 캐시 메모리 역할을 수행하기 위해 페이지 테이블의 일부를 저장함.

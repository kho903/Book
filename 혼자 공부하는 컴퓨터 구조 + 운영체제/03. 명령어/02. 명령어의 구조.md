# 명령어의 구조
## 연산 코드와 오퍼랜드
- 컴퓨터 속 명령어도 '무엇을 대상으로, 어떤 작동을 수행하라'라는 구조로 되어 있다.
- 명령어는 연산 코드 + 오퍼랜드로 구성.
- 명령어가 수행할 연산을 '연산 코드', 연산에 사용할 데이터가 저장된 위치를 '오퍼랜드'라고 하는데, 연산 코드는 연산자, 오퍼랜드는 피연산자라고도 부른다.

### 오퍼랜드
- '연산에 사용할 데이터' 또는 '연산에 사용할 데이터가 저장된 위치'를 의미. 따라서, 숫자와 문 등을 나타내는 데이터 또는 메모리나 레지스터 주소가 올 수 있다.
- 직접 명시 보다는 주소나 레지스터 이름을 주로 담아, 주소 필드라고도 부름
- 명령어는 0개 이상 여러 개 올 수 있어, 명령어의 개수에 따라 n-주소 명령어라고 한다.

### 연산 코드
- 가장 기본적인 연산 코드 유형은 크게 4가지
  - 데이터 전송
  - 산술/논리 연산
  - 제어 흐름 변경
  - 입출력 제어
- 명령어의 종류와 생김새는 CPU마다 다르다. 연산 코드 또한 다름.
- 아래 내용은 외울 필요 없이 어떤 연산의 종류가 있다 정도로만 알아둘 것.

#### 데이터 전송
- MOVE : 데이터를 옮겨라.
- STORE : 메모리에 저장하라.
- LOAD(FETCH) : 메모리에서 CPU로 데이터를 가져와라.
- PUSH : 스택에 데이터를 저장하라.
- POP : 스택의 최상단 데이터를 가져와라.

#### 산술/논리 연산
- ADD / SUBTRACT / MULTIPLY / DIVIDE : 덧셈 / 뺄셈 / 곱셈 / 나눗셈을 수행하라.
- INCREMENT / DECREMENT : 오퍼랜드에 1을 더하라 / 오퍼랜드에 1을 빼라.
- AND / OR / NOT : AND / OR / NOT 연산을 수행하라.
- COMPARE : 두 개의 숫자 또는 TRUE / FALSE 값을 비교하라.

#### 제어 흐름 변경
- JUMP : 특정 주소로 실행 순서를 옮겨라.
- CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라.
- HALT : 프로그램의 실행을 멈춰라.
- CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라.
- RETURN : CALL을 호출할 때 저장했던 주소로 돌아가라.

#### 입출력 제어
- READ (INPUT) : 특정 입출력 장치로부터 데이터를 읽어라.
- WRITE (OUTPUT) : 특정 입출력 장치로 데이터를 써라.
- START IO : 입출력 장치를 시작하라.
- TEST IO : 입출력 장치의 상태를 확인하라.

## 주소 지정 방식
- 오퍼랜드 필드에 연산코드의 데이터보다는 메모리나 레지스터의 주소를 담는 이유는 명령어의 길이 때문.
- 하나의 명령어가 n 비트로 구성되고 연산 코드 필드가 m 비트라면 오퍼랜드 필드에 할당 가능한 길이는 1-주소 명령어라 해도 n-m 비트가 된다.
  - 가령 2-주소 명령어에서 16비트 명령어, 연산 코드 필드가 4비트라면 오퍼랜드 필드당 6비트 정도밖에 남지 않아, 정보의 가짓수는 2^6개밖에 되지 않는다.
- 하지만 만약 오퍼랜드 필드 안에 메모리 주소가 담긴다면 표현할 수 있는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커진다.
  - 예를 들어 한 주소에 16비트 메모리가 있을 때, 이 메모리 안에 데이터를 저장하고, 오퍼랜드 필드 안에 해당 메모리 주소를 명시한다면 표현할 수 있는 정보의 가짓수가
    2^16으로 확 커진다.
- 연산 코드에 사용할 데이터가 저장된 위치, 즉, 연산의 대상이 되는 데이터가 저장된 위치를 유효 주소라고 한다.
- 이렇게 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법을 주소 지정 방식이라고 한다. 즛, 주소 지정 방식은 유효 주소를 찾는 방법.

### 즉시 주소 지정 방식
- 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식. 가장 간단.
- 연산에 사용할 데이터의 크기가 작아진다는 단점이 있지만, 연산에 사용할 데이터를 메모린 레지스터로부터 찾는 과정이 없어 빠름.

### 직접 주소 지정 방식
- 오퍼랜드에 유효 주소를 직접적으로 명시하는 방식.
- 유효 주소를 표현할 수 있는 크기가 연산 코드만큼 줄어듦.

### 간접 주소 지정 방식
- 오퍼랜드 필드에 유효 주소의 주소를 직접적으로 명시.
- 두 번의 메모리 접근으로 앞선 방식들보다 느림.

### 레지스터 주소 지정 방식
- 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방식.
- 메모리에 접근하는 것보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠르다.
- 표현할 수 있는 레지스터 크기에 제한이 생길 수도 있다.

### 레지스터 간접 주소 지정 방식
- 연산에 사용할 데이터를 메모리에 저장하고, 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방식.
- 유효 주소를 찾는 과정이 간접 주소 지정 방식과 비슷하지만, 메모리에 접근하는 횟수가 한 번으로 줄어듦.

#### 주소 지정 방식 정리
- 주소 지정 방식 : 연산에 사용할 데이터를 찾는 방법
- 유효 주소 : 연산에 사용할 데이터가 저장된 위치
- 오퍼랜드 필드에 명시하는 값
  - 즉시 주소 지정 방식 : 연산에 사용할 데이터
  - 직접 주소 지정 방식 : 유효 주소 (메모리 주소)
  - 간접 주소 지정 방식 : 유효 주소의 주소
  - 레지스터 주소 지정 방식 : 유효 주소 (레지스터 이름)
  - 레지스터 간접 주소 지정 방식 : 유효 주소를 저장한 레지스터

## 정리
- 명령어는 연산 코드와 오퍼랜드로 구성.
- 연산 코드는 명령어가 수행할 연산을 의미.
- 오퍼랜드는 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치를 의미.
- 주소 지정 방식은 연산에 사용할 데이터 위치를 찾는 방법.


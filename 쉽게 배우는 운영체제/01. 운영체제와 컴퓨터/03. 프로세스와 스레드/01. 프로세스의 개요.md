# 프로세스의 개요
## 1. 프로세스의 개념
- 프로그램은 저장장치에 저장되어 있는 정적인 상태, 프로세스는 실행을 위해 메모리에 올라온 동적인 상태
- 프로그램이란 어떤 데이터를 사용하여 어떤 작업을 할지 그 절차를 적어놓은 것.
- 프로세스는 실행한다라고 표현하는데, 프로그램으로 작성된 작업 절차를 실제로 실행에 옮기는 것.
- 누군가가 작성한 프로그램이 실행되면 프로세스가 된다.

## 2. 요리사 모형에의 비유
### 2.1 주문서의 역할
- 주문서에는 어떤 코스 요리를 선택했는지, 특별 주문사항이 뭔지 나타나 있다.
- 요리의조리 방법과 요리가 나가는 순서를 결정하는 중요한 자료
- 주방에 전달되면 요리사는 주문서에 적힌 대로 요리를 하여 제공

### 2.2 일괄 작업 방식의 요리
- 일괄 작업 시스템은 한 번에 하나의 작업만 처리하는 것으로, 레스토랑에 테이블 하나뿐이어서 한 테이블만 손님을 받고, 그 손님이 나가야 다음 손님을 받을 수 있다.

### 2.3 시분할 방식의 요리
- 시간을 적당히 배분하여 여러 가지 요리를 동시에 하는 방식 (CPU가 시간을 쪼개어 여러 프로세스에 배분함으로써 동시에 실행하는 것처럼 느껴지게 하는 것)
- 손님이 주문하면 주문서를 주문 목록에 올리고 하나를 가져다가 요리를 하는데, 단품 하나를 만든 후 그 주문서를 주문 목록의 맨 뒤로 옮긴다. 그리고 다른 주문서를
가져다가 단품을 만든다. 그리고 주문서의 모든 요리가 제공되면 주문 목록에서 삭제된다.
- 주문서가 주문 목록에 올라온다는 것은 요리의 시작, 요리하는 동안 주문서는 대기 혹은 요리하는 상태를 왕복, 모든 요리 제공 시 주문 목록에서 삭제되고,
종료되었음을 의미

### 2.4 시분할 방식에서의 예상치 못한 상황 처리
- 재료 손질이 안되었다든지 등의 예상치 못한 상황 발생 시 대기 목록으로 옮기고 다른 주문서를 가져와 요리할 수 있다.
- 대기 목록으로 보냄으로써 다른 작업을 할 수 있기 때문에 작업의 효율성이 높아진다.
- 손님이 급한 일로 음식을 천천히 요청 또는 식사를 포기할 수 있을 경우가 있다. 이와 같이 언제 다시 시작될 지 모를 경우 보류 목록으로 옮기고 재요청시
주문 목록으로 보낸다. (식사 포기 시, 폐기) 따라서 대기목록과 구분됨
- 시분할 방식을 이용한 요리와 운옃체제 프로세스 처리는 유사. 

## 3. 프로그램에서 프로세스로의 전환
- 프로세스는 컴퓨터 시스템의 작업 단위로 태스크라고도 부름
- 운영체제는 프로그램을 메모리의 적당한 위치로 가져오면 주문서에 해당하는 작업지시서를 만드는데, 이 작업 지시서가 프로세스 제어블록(PCB)이다.
- PCB에는 프로세스를 처리하는 다양한 정보가 들어있다. 어떤 프로그램이 프로세스가 되었다는 것은 운영체제로부터 PCB를 받았다는 의미.
- 프로세스 제어 블록 (PCB)의 대표적인 정보
  - 프로세스 구분자 : 각 프로세스를 구분하는 프로세스 구분자 (PID)가 존재
  - 메모리 관련 정보 : 프로세스의 메모리 위치 정보와 메모리 보호를 위한 경계 레지스터와 한계 레지스터 포함
  - 각종 중간값 : 프로세스가 사용했던 중간값 저장, 현재 어떤 단품 요리까지 손님에게 제공되었는지 주문서에 표시하는 것과 유사
- 이러한 정보를 보관하는 데이터 구조가 프로세스 제어 블록 (PCB)
- PCB는 운영체제가 해당 프로세스를 위해 관리하는 데이터 구조이기 떄문에 운영체제 영역에서 만들어지고, 프로세스 종료 시 폐기된다.
- 프로세스와 프로그램의 관계
  - 프로세스 = 프로그램 + 프로세스 제어 블록 (PCB)
  - 프로그램 = 프로세스 - 프로세스 제어 블록 (PCB)

## 4. 프로세스의 상태
- 운영체제에서 여러 가지 이유로 프로세스 상태가 변화됨
- 일괄 작업 시스템에서의 프로세스 상태는 생성 (create), 실행 (run), 완료 (terminate)
- 시분할 시스템에서는 실행 중인 프로세스가 중간에 다른 프로세스에 CPU를 넘겨주는 일이 빈번해 준비 상태가 추가된다.

### 4.1 프로세스의 네 가지 상태
- 생성 상태 (create status)
  - 메모리에 올라와 실행 준비를 완료한 상태로, PCB 생성
- 준비 상태 (ready status)
  - 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태
  - CPU 스케줄러가 다음 실행할 프로세스를 선정
  - 선정된 프로세스를 실행 상태로 바꾸는 CPU 스케줄러의 작업을 디스패치 라고 한다.
- 실행 상태 (running status)
  - 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행하는 상태
  - 프로세스에 배당된 작업 시간을 타임 슬라이스 또는 타임 퀀텀이라 부름
  - 새로운 프로세스가 실행 상태로 들어오면 CPU는 일정 시간 (타임 슬라이스)이 흐른 뒤 알려달라고 클록에 요청 (알람을 맞추는 것 같은 개념)
  - 주어진 시간 안에 작업이 끝나지 않았을 때, 프로세스 준비 상태로 돌아와 다음 차례를 기다림 (타임 아웃)
  - 이처럼 준비 상태와 실행 상태를 왔다 갔다 함
- 완료 상태 (terminate status)
  - 실행 상태의 프로세스가 작업을 마친 상태로 프로세스 제어 블록(PCB)이 사라진 상태

### 4.2 프로세스의 다섯 가지 상태
- 오늘날 운영체제 효율성을 고려하여 추가된 대기 상태
- 대기 상태는 입출력을 요구한 프로세스가 입출력이 완료될 때까지 기다리는 상태
- 입출력을 요청한 프로세스가 대기 상태로 옮겨지면 CPU 스케줄러는 준비 상태에 있는 프로세스 중 하나를 가져다 실행 상태로 만든다.
- 시스템 입장에서 새로운 작업 진행으로 효율성이 높아짐
- 대기 상태의 프로세스는 요청한 입출력이 완료되면 입출력 관리자로부터 인터럽트를 받고, 준비 상태로 돌아가 저ㅏ기 차례를 기다린다.
- 프로세스의 상태와 작업
  - 생성 상태 : 프로그램을 메모리에 올라오고 실행 준비가 완료된 상태 (PCB를 할당 받음)
    - 메모리 할당, PCB 생성
  - 준비 상태 : 실행 대기 중인 모든 프로세스가 자기 순서를 기다리는 상태로, PCB는 준비 큐에서 기다리며 CPU 스케줄러가 관리
    - dispatch(PID) : 준비 -> 실행 (PCB 선택하는 작업)
  - 실행 상태 : 프로세스가 CPU를 할당받아 실행되는 상태로 프로세스 사이의 문맥 교환이 일어남
    - timeout(PID) : 실행 -> 준비 (주어진 시간 초과)
    - exit(PID) : 실행 -> 완료 (작업 완료)
    - block(PID) : 실행 -> 대기 (입출력 요청)
  - 대기 상태 : 실행 상태의 프로세스가 입출력 요청 시 완료까지 기다리는 상태. 입출력 완료시 준비상태로 감
    - wakeup(PID) : 대기 -> 준비 (입출력 완료)
  - 완료 상태 : 프로세스가 종료되는 상태. 정상종료인 exit, 비정상 종료인 abort 모두 포함
    - 메모리 삭제, 프로세스 제어 블록 (PCB) 삭제

### 4.3 휴식 상태와 보류 상태
- 대부분의 프로세스는 생성, 준비, 실행, 대기, 완료 상태로 운영되고 이를 활성 상태 (active status) 라고 한다.
- 이외에 휴식, 보류 상태가 있다.
- 휴식 상태 
  - 프로세스가 작업을 일시적으로 쉬고 있는 상태
  - 사용하던 데이터가 메모리에 그대로 있고 프로세스 제어 블록도 유지되므로 멈춘 지점에서부터 재시작 가능
- 보류 상태 
  - 프로세스가 메모리에서 잠시 쫒겨난 상태. 휴식 상태와 차이가 있다.
  - 다음과 같은 상황에서 보류 상태가 됨
    - 메모리가 꽉 차서 일부 프로세스를 메모리 밖으로 보낼 때
    - 프로그램에 오류가 있어 실행을 미룰 때
    - 바이러스와 같은 악의적 공격 프로세스라 판단될 떄
    - 매우 긴 주깅로 반복되는 프로세스라 메모리 밖으로 쫓아내도 큰 문제가 없을 때
    - 입출력 기다리는 프로세스의 입출력이 계속 지연될 때
  - 메모리 밖 스왑 영역 (메모리에서 쫓겨난 데이터가 임시로 보관되는 곳)에 보관된다.
  - 보류 상태는 스왑 영역, 휴식 상태는 프로세스가 메모리에 있으나 멈춘 상태
  - 보류 상태는 대기 상태에서 옮겨진 보류 대기 상태, 준비 상태에서 옮겨진 보류 준비 상태로 구분. 활성 시 원래의 활성 상태로 들어감

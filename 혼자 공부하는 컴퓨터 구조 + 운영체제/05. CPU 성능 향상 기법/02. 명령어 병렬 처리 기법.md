# 명령어 병렬 처리 기법
- 명령어 병렬 처리 기법은 명령어를 동시에 처리하여 CPU를 한시도 쉬지 않고 작동시키는 기법.
- 대표적인 명령어 병렬 처리 기법은 명령어 파이프라이닝, 슈퍼스칼라, 비순차적 명령어 처리가 있다.

## 명령어 파이프라이닝
- 명령어가 처리되는 전체 과정을 클럭 단위로 나누면 다음과 같다.
1. 명령어 인출 (Instruction Fetch)
2. 명령어 해석 (Instruction Decode)
3. 명령어 실행 (Execute Instruction)
4. 결과 저장 (Write Back)
- 중요한 점은 같은 단계가 겹치지만 않는다면 CPU는 '각 단계를 동시에 실행할 수 있다'는 것이다. 예를 들면 한 명령어를 '인출'하는 동안 다른 명령어를 '실행'할 수 있고, 한 명령어가
'실행'되는 동안 '저장'할 수 있다.
- 공장 생산 라인과 같이 명령어들을 명령어 파이프라이닝에 넣고 동시에 처리하는 기법을 명령어 파이프라이닝이라고 한다.
- 파이프라이닝이 높은 성능을 가져오기는 하지만, 특정 상황에서는 성능 향상에 실패하는 경우도 있다. 이러한 상황을 파이프라인 위험이라고 부르고, 파이프라인 위험에는 크게
데이터 위험, 제어 위험, 구조적 위험이 있다.

### 데이터 위험
- 데이터 위험(data hazard)은 명령어 간 '데이터 의존성'에 의해 발생.
- 모든 명령어를 동시에 처리할 수는 없고 어떤 명령어는 이전 명령어를 끝까지 실행해야만 비로소 실행할 수 있는 경우가 있다. 아래와 같은 예가 있다.
```text
명령어 1 : R1 <- R2 + R3   // R2 레지스터 값과 R3 레지스터 값을 더한 값을 R1 레지스터에 저장
명령어 2 : R4 <- R1 + R5   // R1 레지스터 값과 R5 레지스터 값을 더한 값을 R4 레지스터에 저장
```
- 명령어 1을 수행해야만 2를 수행 가능. 즉, R1에 R2 + R3 결과값이 저장되어야 명령어 2를 수행할 수 있다. 그 전에 명령어 2를 인출하면 원치 않은 R1 값으로 명령어2 를 수행한다.
- 따라서 명령어 2는 명령어 1의 데이터에 의존적이다. 이처럼 데이터 의존적인 두 명령어를 무작정 동시에 실행하려고 하면 파이프라인이 제대로 작동하지 않는 것을 '데이터 위험'이라고 한다.

### 제어 위험
- 제어 위험 (control hazard)은 주로 분기 등으로 인한 '프로그램 카운터의 갑작스러운 변화'에 의해 발생.
- 기본적으로 프로그램 카운터는 '현재 실행 중인 명령어의 다음 주소'로 갱신된다. 하지만 프로그램 실행 흐름이 바뀌어 명령어가 실행 중 프로그램 카운터 값에 갑작스러운 변화가
생긴다면 명령어 파이프라인에서 미리 처리 중이던 명령어들은 아무 쓸모가 없어진다. 이를 '제어 위험'이라고 한다.
- 이를 위해 사용되는 '분기 예측'(branch prediction)은 프로그램이 어디로 분기할지 미리 예측한 후 그 주소를 인출하는 기술.

### 구조적 위험
- 구조적 위험(structural hazard)은 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할 때 발생.
- 구조적 위험은 자원 위험(resource hazard)라고도 불림

## 슈퍼스칼라
- 파이프라이닝은 단일 파이프라인으로도 구현 가능. but, 오늘날 대부분의 CPU에서는 여러 개의 파이프라인 이용. CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조를 
슈퍼스칼라(superscalar).
- 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU를 슈퍼스칼라 프로세서 또는 슈퍼스칼라 CPU라고 한다.
- 슈퍼스칼라 프로세서는 매 클럭 주기마다 동시에 여러 명령어를 인출, 실행할 수도 있어야 한다.
- 슈퍼스칼라 프로세서는 이론적으로 파이프라인 개수에 비례하여 프로그램 처리 속도가 빨라지지만 파이프라인 위험 등의 예상치 못한 문제로 비례하여 빨라지지는 않는다. 하나의 파이프라인을
이용할 때보다 데이터 위험, 제어 위험, 자원 위험을 피하기가 더욱 까다롭기 때문이다.

## 비순차적 명령어 처리
- 비순차적 명령어 처리(OoOE : Out-of-Order Execution)은 오늘날 CPU 성능 향상에 크게 기여한 기법이자 대부분의 CPU가 차용하는 기법으로, 명령어들을 순차적으로 실행하지 않는
기법이다. 명령어의 '합법적인 새치기'라고 볼 수 있다.
- 예를 통해 보자.
```text
1 : M(100) <- 1
2 : M(101) <- 2
3 : M(102) <- M(100) + M(101)
4 : M(150) <- 1
5 : M(151) <- 2
6 : M(152) <- 3
```
- 3번 명령어 실행을 위해서는 M(100), M(101) 값이 결정되어야 하기에 1, 2 번 명령어 실행이 끝날때까지는 기다려야 한다.
- 그런데 앞의 코드를 이루는 명령어들 중에 서로 데이터 의존성이 전혀 없는, 순서를 바꿔 처리해도 수행 결과에 영향을 미치지 않는 명령어가 존재.
- 3번 명령어가 맨 마지막으로 실행되어도 문제될 것 없고, 더 효율적으로 실행된다. 
- 이렇게 명령어를 순차적으로만 실행하지 않고 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을 방지하는 기법을 비순차적 명령어 처리 기법이라고 한다.
- 당연하게 의존성이 있는 명령어끼리는 순서를 바꿀 수 없다. 예를 들면 3번 명령어를 위해 1, 2번 명령어가 필요하듯, 1<->3 또는 2 <-> 3 은 바꿀 수 없다.
- 비순차적 명령어 처리가 가능한 CPU는 명령어들이 어떤 명령어와 데이터 의존성을 가지고 있는지, 순서를 바꿔 실행할 수 있는 명령어에는 어떤 것들이 있는지를 판단할 수 있어야 한다.

## 키워드 정리
- 명령어 파이프라이닝은 동시에 여러 개의 명령어를 겹쳐 실행하는 기법.
- 슈퍼스칼라는 여러 개의 명령어 파이프라인을 두는 기법.
- 비순차적 명령어 처리 기법은 파이프라인의 중단을 방지하기 위해 명령어를 순차적으로 처리하지 않는 기법.


# 6.1 컬렉터란 무엇인가?
- 앞 예제는 명령형 프로그래밍에 비해 함수형 프로그래밍이 얼마나 편리한지 명확하게 보여줌. 함수형 프로그래밍에서는 '무엇'을 원하는지 직접 명시할 수 있어 어떤 방법으로 이를 얻을지는 신경 쓸 필요가 없음.
- 앞에서 collect 메서드로 Collector 인터페이스 구현을 전달했음. Collector 인터페이스 구현은 스트림의 요소를 어떤 식으로 도출할지 지정함.
- 지금까지 '각 요소를 리스트로 만들어라'를 의미하는 toList를 Collector 인터페이스의 구현으로 사용했음. 여기서는 groupingBy를 이용해 '각 키(통화) 버킷(bucket) 그리고 각 키 버킷에 대응하는 요소
리스트를 갑승로 포함하는 맵(Map)을 만들라'는 동작을 수행함.
- 다수준(multilevel)으로 그룹화를 수행할 때 명령형 프로그래밍과 함수형 프로그래밍의 차이점이 더욱 두드러짐. 명령형 코드에서는 문제를 해결하려는 과정에서 다중 루프, 조건문으로 가독성, 유지보수성이 떨어짐.
- 함수형 프로그래밍에서는 필요한 컬렉터를 쉽게 추가 가능.

## 6.1.1 고급 리듀싱 기능을 수행하는 컬렉터
- 훌륭하게 설계된 함수형 API의 또 다른 장점으로 높은 수준의 조합성과 재사용성이 있음. collect로 결과를 수집하는 과정을 간단하면서도 유연한 방식으로 정의 가능한 것이 컬렉터의 최대 강점. 구체적으로 스트림에
collect를 호출하면 스트림의 요소에 (컬렉터로 파라미터화된) 리듀싱 연산이 수행됨.
- collect에서는 리듀싱 연산을 이용해서 스트림의 각 요소를 방문하면서 컬렉터가 작업을 처리함.
- 보통 함수를 요소로 변환(toList처럼 데이터 자체를 변환하는 것보다는 데이터 저장 구조를 변환할 때가 많다)할 때는 컬렉터를 적용해 최종 결과를 저장하는 자료구조에 값을 누적함. 예를 들어 이전 트랜잭션 그룹화
예제에서 변환 함수는 각 트랜잭션에서 통화를 추출한 다음에 통화를 키로 사용해서 트랜잭션 자체를 결과 맵에 누적했음.
- 통화 예제에서 보여주는 것처럼 Collector 인터페이스의 메서드를 어떻게 구현하느냐에 따라 스트림에 어떤 리듀싱 연산을 수행할지 결정됨. Collectors 유틸리티 클래스는 자주 사용하는 컬렉터 인스턴스를 손쉽게
생성할 수 있는 정적 팩토리 메서드를 제공함. 예를 들어 가장 많이 사용하는 직관적인 정적 메서드로 toList를 꼽을 수 있음. toList는 스트림의 모든 요소를 리스트로 수집함.
```java
List<Transaction> transactions = transactionStream.collect(Collectors.toList());
```

## 6.1.2 미리 정의된 컬렉터
- 미리 정의된 컬렉터, 즉 groupingBy 같이 Collectors 클래스에서 제공하는 팩토리 메서드 기능을 알아보자. Collectors에서 제공하는 메서드의 기능은 크게 세 가지로 구분 가능.
  - 스트림 요소를 하나의 값으로 리듀스하고 요약
  - 요소 그룹화
  - 요소 분할
- 먼저 리듀싱과 요약 (summarize) 관련 기능을 수행하는 컬렉터부터 살펴보자. 트랜잭션 리스트에서 트랜잭션 총합을 찾는 등의 다양한 계산을 수행할 때 이들 컬렉터를 유용하게 활용 가능.
- 다음으로 스트림 요소를 그룹화하는 방법을 살펴보자. 이전 예제를 다수준으로 그룹화하거나 각각의 결과 서브그룹에 추가로 리듀싱 연산을 적용할 수 있도록 다양한 컬렉터를 조합하는 방법을 알아보자. 또한 그룹화의
특별한 연산인 분할(partitioning)도 알아보자. 분할은 한 개의 인수를 받아 불리언을 반환하는 함수, 즉 프레디케이트를 그룹화 함수로 사용함.

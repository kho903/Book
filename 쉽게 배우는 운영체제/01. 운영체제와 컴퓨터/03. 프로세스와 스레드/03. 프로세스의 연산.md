# 프로세스의 연산
## 1. 프로세스의 구조
### 요리에 비유
- 코드 영역 : 요리 책 - 요리책에 레시피가 나와 있듯, 코드 영역에 프로세스의 본문이 기술됨
- 데이터 영역 : 재료 - 요리를 완성하려면 재료가 있어야 하듯, 필요한 데이터들이 프로세스의 데이터 영역에 해당
- 스택 영역 : 조리 도구 - 요리를 위한 조리 도구가 필요하듯, 코드 동작을 위해 운영체제가 부수적으로 관리하는 데이터 영역

### 코드 영역
- 프로그램의 본문이 기술된 곳으로 텍스트 영역이라고도 함
- 프로그래머가 작성한 프로그램이 탑재되며 읽기 전용으로 처리됨

### 데이터 영역
- 코드가 실행되면서 사용하는 변수나 파일 등의 각종 데이터를 모아놓은 곳
- 변하는 값이므로 대부분 읽기와 쓰기 모두 가능 (상수 : 읽기전용)

### 스택 영역
- 운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳
- 예 : 함수 호출 시 함수 수행 후 원래 프로그램으로 돌아올 위치 저장
- 사용자에게는 보이지 않음

## 2. 프로세스의 생성과 복사
- 프로세스는 프로그램 실행 시 새로 생성
- 새로 생성 뿐 아니라, 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 방법도 있다.

### 2.1 fork() 시스템 호출의 개념
- 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수
- 커널에서 제공하는 일종의 시스템 호출
- 기존 프로세스는 부보 프로세스, 새로 생긴 프로세스는 자식 프로세스가 되며, 두 프로세스는 부모-자식 관계

### 2.2 fork() 시스템 호출의 동작 과정
- fork() 시스템 호출을 하면 프로세스 제어 블록을 포함한 부모 프로세스 영역의 대부분이ㅐ 자식 프로세스에 복사되어 똑같은 프로세스가 만들어지는데,
프로세스 구분자(PID), 메모리 관련 정보가 바뀌고, 부모 프로세스 구분자(PPID), 자식 프로세스 구분자(CPID)가 바뀐다. (부모의 CPID에 자식 프로세스의 PPID가 저장되고,
자식 프로세스의 자식이 없을 경우 자식 프로세스의 구분자의 값은 -1.)

### 2.3 fork() 시스템 호출의 장점
#### 프로세스의 생성 속도가 빠르다.
#### 추가 작업 없이 자원을 상속할 수 있다.
- 부모의 모든 자원을 자식 프로세스에 상속 가능
#### 시스템 관리를 효율적으로 할 수 있다.
- 부모-자식간에 구분자로 연결되어 있어, 자식 프로세스 종료 시, 부모 프로세스가 해당 자원을 정리 가능 
  - 프로세스 종료시, 메모리 영역, 파일, 하드웨어를 잘 정리해야 함. 부모에게 맡겨 효율적으로 관리 가능

### 2.4 fork() 시스템 호출의 예
- fork()문을 만나면 똑같은 내용의 자식 프로세스 하나 생성, 부모 프로세스에 0보다 큰 값 반환, 자식은 0을 반환
- 0보다 작은 경우 자식 프로세스가 생성되지 않은것으로 여기고 error
- fork()문 이전에 파일을 열거나 변수를 선언하면 자식 프로세스에 상속됨

## 3. 프로세스의 전환
### 3.1 exec() 시스템 호출의 개념
- 기존 프로세스를 새로운 프로세스로 전환하는 함수
- fork() : 새로운 프로세스를 복사하는 시스템 호출
- exec() : 프로세스를 그대로 둔 채 내용만 바꾸는 시스템 호출
- 목적 : 프로세스의 구조체 재활용
- 새로운 프로세스를 만들려면 PCB 만들기 -> 메모리 자리 확보, 프로세스 종료 후 GC위해 부모-자식 관계 생성 필요
- exec()을 통해 이미 만들어진 PCB, 메모리 영역, 부모-자식 관계를 그대로 사용할 수 있어 편리, 운영체제 작업 수월

### 3.2 exec() 시스템 호출의 동작 과정
- exec() 호출 시 각종 프로세스 구분자만 남겨두고 프로세스의 나머지 내용 리셋, 코드 영역의 기존 내용을 새로운 코드로 바꿔버림
- 데이터 영역은 새로운 변수로 채워지고, 스택 영역이 리셋됨
- 정리하자면, 구분자 정보, 메모리 관련 사항 외에 각종 레지스터, 사용한 파일정보 모두 리셋되고, 프로세스를 처음 시작하는 것처럼 정리됨

### 3.3 exec() 시스템 호출의 예
- fork()와 exec() 시스템 호출을 사용한 mplayer 실행 코드
- 부모 프로세스
```c
#include <stdio.h>
#include <unistd.h>

void main() 
{
  int pid;
  
  pid = fork(); // 자식 프로세스 생성
  if (pid < 0) {
    printf("Error");
    exit(-1);
  } else if (pid == 0) { /* 자식 프로세스 */
    execlp("mplayer", "mplayer", NULL); // 자식 프로세스의 코드 영역이 mplayer의 코드로 바뀌어 처음부터 다시 실행됨
    exit(0);
  } else {
    wait(NULL); // 자식 프로세스가 끝날 때까지 기다린다. 자식 프로세스가 끝나면 돌아오는 곳.
    printf("mplayer Terminated");
    exit(0);
  }
}
```
- 자식 프로세스 (exec() 실행)
```c
/* mplayer - music player */
void main() {
  // ... mplayer 실행 코드
}
```
- exec() 시스템 호출을 사용하여 새로운 프로세스로 전환하더라도 프로세스 제어 블록의 각종 프로세스 구분자가 변경되지 않아 종료 후 부모 프로세스로 돌아올 수 있다.

## 4. 프로세스의 계층 구조
### 4.1 유닉스의 프로세스 계층 구조
- 유닉스에서 커널이 처음 메모리에 올라와 부팅이 되면 커널 관련 프로세스를 여러 개 만드는데, 그중 init 프로세스는 전체 프로세스의 출발점이 된다.
- 모든 프로세스는 init 프로세스의 자식.
- init 프로세스는 일반 사용자 프로세스의 맨 위에 위치. fork(), exec()로 자식 프로세스를 만들고, 그 자식 프로세스로, login, shell 프로세스 등이 있다.

### 4.2 프로세스 계층 구조의 장점
1. 여러 작업의 동시 처리
- login 프로세스는 인증을 거쳐 컴퓨터에 접속, 동시에 여러 사용자 처리 위해 fork() 시스템 호출로 login 프로세스를 여러 개 만들어 사용자에게 나누어줌
  - login 프로세스는 한 번에 1명만 처리 가능, 위 작업 반복으로 여러 사용자 동시 처리 가능
- login 프로세스 통과 후 shell 프로세스
  - 사용자가 운영체제에 명령을 내리고 결과를 받기 위함
  - login 프로세스가 작업을 마치면 메모리 공간이 비워지고 PCB 제거 후 새로 공간 확보 후 PCB 재생성
  - 이 과정이 비효율적이므로, exec() 시스템 호출로 login 프로세스의 구조를 shell 프로세스로 다시 활용 후 사용자 명령 대기
- shell 프로세스에서 명령어로 응용 프로그램을 실행할 때도 fork(), exec() 시스템 호출 이용
2. 용이한 자원 회수
- 프로세스 간의 책임 관계가 분명해져 시스템 관리 수월
- 모든 프로세스를 부모-자식 관계로 만들면 자식 프로세스 완료 후 사용자원을 부모 프로세스가 회수하면 된다.

### 4.3 미아 프로세스
- 부모 프로세스는 자원 회수를 위해 자식 프로세스가 끝날 때까지 기다려야 하는데, 부모 프로세스가 먼저 종료, 혹은 자식 프로세스가 비정상 종료 시,
자식 프로세스 종료가 안되거나, 사용하던 자원이 그대로 남게 될 수 있다. 이 프로세스를 미아 프로세스 또는 좀비 프로세스라 한다.
- C언어에서 exit(), return()문이 이를 방지하기 위해 부모 프로세스에 알리는 것이다.

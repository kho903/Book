# 32. 테이블 결합
- 테이블 결합(join)은 RDBMS에서 중요한 개념.
- 테이블의 집합 연산에는 세로(행) 방향으로 데이터가 늘어나거나 줄어드는 계산을 했다. 결합에서는 가로(열) 방향으로 데이터가 늘어나는 계산.
- 보통 데이터베이스는 하나의 테이블에 많은 데이터를 저장하지 않고 몇 개의 테이블로 나누어 저장. 여러 개로 나뉜 데이터를 하나로 묶어 결과를 내는 방법이 테이블 결합.
결합을 이해하는 동시에 기본이 되는 개념이 집합론의 '곱집합'.

## 1. 곱집합과 교차결합
- 곱집합은 합집합이나 교칩합처럼 집합의 연산 방법 중 하나. 두 개의 집합을 곱하는 연산 방법으로 '직접합' 또는 '카티전곱(Cartesian product)'라고도 불림.
- 예로, 집합 X는 {A,B,C} 집합 Y는 {1,2,3} 요소를 가질때, 집합 X, Y의 곱집합은 집합 X의 요소 A에 집합 Y의 각 요소를 붙여 계산하는 것.
```text
{
    (A,1), (A,2), (A,3),
    (B,1), (B,2), (B,3),
    (C,1), (C,2), (C,3)
}
```
### 교차결합 (Cross Join)
- 데이터베이스의 테이블은 집합의 한 종류라고 할 수 있다. 지금까지 SELECT 명령에서는 FROM 구에 하나의 테이블만 지정했다. 만약 테이블을 두 개 지정하면 곱집합으로 
계산됨.
- 교차결합
```text
SELECT * FROM 테이블명1, 테이블명2
```
- FROM 구로 곱집합을 구해 보자.
```text
mysql> select * from sample72_x;
+------+
| x    |
+------+
| A    |
| B    |
| C    |
+------+
3 rows in set (0.01 sec)

mysql> select * from sample72_y;
+------+
| y    |
+------+
|    1 |
|    2 |
|    3 |
+------+
3 rows in set (0.00 sec)

mysql> select * from sample72_x, sample72_y order by y, x;
+------+------+
| x    | y    |
+------+------+
| A    |    1 |
| B    |    1 |
| C    |    1 |
| A    |    2 |
| B    |    2 |
| C    |    2 |
| A    |    3 |
| B    |    3 |
| C    |    3 |
+------+------+
9 rows in set (0.00 sec)
```
- 실행 결과, 집합이 계산된 것을 알 수 있다. FROM 구에 복수의 테이블을 지정하면 교차결합을 한다. 교차결합은 두 개의 테이블을 곱집합으로 계산.
> FROM 구에 복수의 테이블을 지정하면 교차결합을 한다!

### UNION 연결과 결합 연결 차이
- 앞서 UNION 에서도 집합을 더해 새로 큰 집합을 만들어 계산할 수 있었다. 한편으로는 FROM 구에서 복수의 테이블을 결합할 때도 새로 큰 집합을 만들어 계산함.
- 두 방식이 서로 비슷하지만 확대 방햐잉 다름. UNION으로 합집합을 구하면 세로 방향으로 더해지고 FROM 구로 테이블을 결합하면 가로 방향으로 더해짐.

## 2. 내부결합
- FROM 구에 테이블 복수 지정시 곱집합으로 되는 것을 알아보았다. 두 테이블만 알아 보았지만, 3, 4개도 지정 가능. 단 테이블 수가 많아지면 조합 수가 엄청나게
늘어나 집합이 거대해짐. 많은 테이블을 교차결합하는 경우는 드물다. 즉, 결합 방법으로는 교차결합보다 내부결합이 자주 사용됨.
- 내부결합에 대해 알아보자. 수학에서 집합으 유일한 요소로 구성됨. 즉, 중복된 값이 존재하지 않는다. 마찬가지로 RDBMS에서도 테이블의 데이터가 유일한 값을 가지도록
권장. 간단히 말하면 기본키(primary key)를 가지도록 하는 것이 좋다.
- 데이터베이스에는 다양한 데이터가 저장되지만 동일한 데이터를 중복해서 여러 곳에 저장하지 않도록 하는 편이 좋다. 만약 데이터가 변경되는 경우 여기저기 저장되어 있는
데이터를 모두 동일한 값으로 변경하기란 힘든 일. 이때 기본키는 하나의 데이터행을 대표할 수 있는 속성을 가진다.
- 예로, 상품의 가격, 이름 데이터 등을 저장하는 '상품 테이블'을 작성할 떄, 상품의 속성으로는 상품명, 메이커명, 가격, 상품분류 등을 꼽을 수 있다. 상품명을 
기본키로 사용한다면 어떨까? 하지만 상품명의 경우 중복 우려가 있어 적합하지 않다. 이러한 이유로 '상품코드'를 기본키로 사용하는 경우가 많음.
- 흔히 볼 수 있는 상품 테이블 구조는 아래와 같다. (한글 테이블명, 열이름 사용)
```text
mysql> create table 상품(
    ->  상품코드 char(4) not null,
    ->  상품명 varchar(30),
    ->  메이커명 varchar(30),
    ->  가격 integer,
    ->  상품분류 varchar(30),
    ->  primary key (상품코드)
    -> );
Query OK, 0 rows affected (0.04 sec)

mysql> desc 상품;
+--------------+-------------+------+-----+---------+-------+
| Field        | Type        | Null | Key | Default | Extra |
+--------------+-------------+------+-----+---------+-------+
| 상품코드     | char(4)     | NO   | PRI | NULL    |       |
| 상품명       | varchar(30) | YES  |     | NULL    |       |
| 메이커명     | varchar(30) | YES  |     | NULL    |       |
| 가격         | int         | YES  |     | NULL    |       |
| 상품분류     | varchar(30) | YES  |     | NULL    |       |
+--------------+-------------+------+-----+---------+-------+
5 rows in set (0.01 sec)

mysql> select * from 상품;
+--------------+-----------+--------------+--------+--------------+
| 상품코드     | 상품명    | 메이커명     | 가격   | 상품분류     |
+--------------+-----------+--------------+--------+--------------+
| 0001         | 상품1     | 메이커1      |    100 | 식료품       |
| 0002         | 상품2     | 메이커2      |    200 | 식료품       |
| 0003         | 상품3     | 메이커3      |   1980 | 생활용품     |
+--------------+-----------+--------------+--------+--------------+
3 rows in set (0.00 sec)
```
- 테이블을 만들어두면 동일한 상품명을 가진 상품명을 가진 상품이라도 구별하여 등록 가능. 일반적인 전자상거래 시스템에서 상품 테이블 하나만으로 운영하는 곳은 없다고
생각해도 무리는 아닐 것. 상품 데이터를 참조하는 별도의 테이블이 존재한다는 의미. 예로, 재고도 같이 관리하는 경우에는 입출고나 재고 수를 상품단위로 관리하는 테이블이
있을 것.
- 만약 재고관리 테이블을 만든다면 다음과 같이 작성 가능.
```text
create table 재고수 (
  상품코드 CHAR(4),
  입고날짜 DATE,
  재고수 INTEGER  
);

mysql> select * from 재고수;
+--------------+------------+-----------+
| 상품코드     | 입고일     | 재고수    |
+--------------+------------+-----------+
| 0001         | 2014-01-03 |       200 |
| 0002         | 2014-02-10 |       500 |
| 0003         | 2014-02-14 |        10 |
+--------------+------------+-----------+
3 rows in set (0.01 sec)
```
- 물론, 실제 시스템에서는 더 많은 열로 구성되어 있을 것. 여기서는 상품 테이블을 참조하는 테이블의 예를 알아보기 위해 간단하게 재고관리 테이블을 만들었다. 이러한
이유로 기본키도 따로 지정하지 않았지만, 재고수 테이브을 참조하는 다른 테이블을 위해 기본키를 지정해두는 것도 좋을 것.
- 재고수 테이블에서의 착안점은 상품코드를 통해 상품 테이불과 연결할 수 있다는 것. 상품 테이블의 기본키는 '상품코드'. 이 열의 값을 알면 상품명을 포함한 상품 
데이터를 참조 가능. 다른 테이블의 데이터를 참조해야 하는 경우, 참조할 테이블의 기본키와 동일한 이름과 자료형으로 열을 만들어 행을 연결하는 경우가 많음.
- 재고수 테이블에서 상품분류가 식료품인 상품의 재고수를 표시하는 경우를 생각해보자. 이 경우 상품코드보다 상품명으로 표시하면 알아보기 쉬울 것이다. 목표는
다음과 같이 표시하는 것.

| 상품명  | 재고수 |
|------|-----|
| 상품OO | 200 |
| 상품XX | 500 |
- 재고수는 재고수 테이블에서 가져오면 되지만 상품명과 상품분류는 상품 테이블에 있다. 이떄 재고수 테이블과 상품 테이블을 결합해 가로로 나열하고자 한다.
그러기 위해서는 FROM 구에서 테이블을 서로 결합.
```text
mysql> select * from  상품, 재고수;
+--------------+-----------+--------------+--------+--------------+--------------+------------+-----------+
| 상품코드     | 상품명    | 메이커명     | 가격   | 상품분류     | 상품코드     | 입고일     | 재고수    |
+--------------+-----------+--------------+--------+--------------+--------------+------------+-----------+
| 0003         | 상품3     | 메이커3      |   1980 | 생활용품     | 0001         | 2014-01-03 |       200 |
| 0002         | 상품2     | 메이커2      |    200 | 식료품       | 0001         | 2014-01-03 |       200 |
| 0001         | 상품1     | 메이커1      |    100 | 식료품       | 0001         | 2014-01-03 |       200 |
| 0003         | 상품3     | 메이커3      |   1980 | 생활용품     | 0002         | 2014-02-10 |       500 |
| 0002         | 상품2     | 메이커2      |    200 | 식료품       | 0002         | 2014-02-10 |       500 |
| 0001         | 상품1     | 메이커1      |    100 | 식료품       | 0002         | 2014-02-10 |       500 |
| 0003         | 상품3     | 메이커3      |   1980 | 생활용품     | 0003         | 2014-02-14 |        10 |
| 0002         | 상품2     | 메이커2      |    200 | 식료품       | 0003         | 2014-02-14 |        10 |
| 0001         | 상품1     | 메이커1      |    100 | 식료품       | 0003         | 2014-02-14 |        10 |
+--------------+-----------+--------------+--------+--------------+--------------+------------+-----------+
9 rows in set (0.00 sec)
```
- FROM 구에 테이블을 복수로 지정하면 곱집합으로 계산됨. 상품 테이블 행에 재고수 데이터 행으로 곱집합을 구하면 행은 3 X 3 = 9개가 됨. 왼쪽이 상품 테이블의
데이터, 오른쪽이 재고수 테이블의 데이터.
- 이렇게 만들어진 집합에서 원하는 데이터 검색 위해 WHERE 구로 조건을 짖어함. 먼저 상품코드가 같다는 조건이 필요함. 앞의 예제에서 상품 테이블의 상품코드와 재고수
테이블의 상품코드가 서로 같은 것을 찾아나가면 됨.
- 열 이름이 `상품코드`로 서로 동일하므로 WHERE 구에 조건식을 지정할 때 테이블 이름도 같이 짖어할 필요가 있따. 다음과 같이 실행해보자.
```text
mysql> select * from 상품, 재고수 where 상품.상품코드 =
재고수.상품코드;
+--------------+-----------+--------------+--------+--------------+--------------+------------+-----------+
| 상품코드     | 상품명    | 메이커명     | 가격   | 상품분류     | 상품코드     | 입고일     | 재고수    |
+--------------+-----------+--------------+--------+--------------+--------------+------------+-----------+
| 0001         | 상품1     | 메이커1      |    100 | 식료품       | 0001         | 2014-01-03 |       200 |
| 0002         | 상품2     | 메이커2      |    200 | 식료품       | 0002         | 2014-02-10 |       500 |
| 0003         | 상품3     | 메이커3      |   1980 | 생활용품     | 0003         | 2014-02-14 |        10 |
+--------------+-----------+--------------+--------+--------------+--------------+------------+-----------+
3 rows in set (0.00 sec)
```
- 이렇게 교차결합으로 계산된 곱집합에서 원하는 조합을 검색하는 것을 '내부결합(Inner Join)'이라 부름. (결합 조건으로 보면 등결합이라고도 부를 수 있음)
- 다음으로는 상품분류가 '식료품'이라는 조건이 필요. 이 조건을 WHERE 구에 추가하자. 추가할 때는 기존 조건식과 상품분류의 조건식이 모두 참이여야 하므로 AND로
조건식을 연결. 또한 상품명과 재고수만 반환하도록 SELECT 구에 열을 지정하낟.
```text
mysql> select 상품.상품명, 재고수.재고수 from 상품, 재고수
    ->  where 상품.상품코드 = 재고수.상품코드
    ->   and 상품.상품분류 = '식료품';
+-----------+-----------+
| 상품명    | 재고수    |
+-----------+-----------+
| 상품1     |       200 |
| 상품2     |       500 |
+-----------+-----------+
2 rows in set (0.00 sec)
```
- 이처럼 원하는 결과를 얻었다. WHERE 구에는 두 개의 조건식이 지정되어 있다. 첫 번째 조건식은 교차결합으로 계산된 곱집합에서 원하는 조합을 검색하는 것. 
- 두 번째 조건식은 결합 조건이 아닌 검색 조건으로 여기에서 첫 번째 조건식의 조건을 '결합조건'이라 부름.

## 3. INNER JOIN으로 내부결합하기
- 지금까지 결합방법에 관해 간단히 정리하면,
  - FROM 구에 테이블을 복수 지정해 가로 방향으로 테이블을 결합할 수 있다.
  - 교차결합을 하면 곱집합으로 계산된다.
  - WHERE 조건을 지정해 곱집합에서 필요한 조합만 검색할 수 있다.
- 하지만 위 결합방법은 모두 구식. 최근에는 INNER JOIN 키워드를 사용한 결합방법이 일반적으로 통용됨.
```text
mysql> select 상품.상품명, 재고수.재고수
    ->  from 상품 inner join 재고수
    ->    on 상품.상품코드 = 재고수.상품코드
    ->  where 상품.상품분류 = '식료품';
+-----------+-----------+
| 상품명    | 재고수    |
+-----------+-----------+
| 상품1     |       200 |
| 상품2     |       500 |
+-----------+-----------+
2 rows in set (0.00 sec)
```
- 내부결합 SYNTAX
```text
SELECT * FROM 테이블명1 INNER JOIN 테이블명2 ON 결합조건
```
- 구식 방법에서는 쉼표(,)로 구분해 테이블을 FROM 구에 지정했다. 새로운 형식에서는 테이블과 테이블 사이에 'INNER JOIN' 키워드를 넣는다. 여기서 INNER는
'안쪽'이라는 의미, JOIN은 '연결시킨다'는 의미이다. 즉, '내부결합'이라는 의미. 구식 방법에서는 WHERE 구에 결합조건을 지정했지만, INNER JOIN에서는
ON을 사용해 결합조건을 지정.
> INNER JOIN으로 두 개 테이블을 가로로 결합할 수 있다!

## 4. 내부결합을 활용한 데이터 관리
- '하나의 데이터는 한 군데에 저장한다'는 룰에 따라 데이터 구조를 설계한다 했을 떄, 메이커코드와 메이커명을 가지는 메이커 테이블을 작성해 데이터를 관리해보자.
- 상품을 제조하는 메이커가 많이 있다 해도, 상품 수보다는 적을 것이다. 이떄 코드와 이름을 가지는 테이블로 분할해 관리하면 저장공간도 절약 가능.
- 메이커코드는 메이커를 나타내는 코드라는 의미에서 맨 앞자를 'M'으로 하였고, 여기서는 두 개의 메이커를 저장하자.

```text
CREATE TABLE 메이커 (
    메이커코드 CHAR(4) NOT NULL,
    메이커명 VARCHAR(30),
    PRIMARY KEY (메이커코드)
);

mysql> select * from 메이커;
+-----------------+--------------+
| 메이커코드      | 메이커명     |
+-----------------+--------------+
| M001            | 메이커1      |
| M002            | 메이커2      |
+-----------------+--------------+
2 rows in set (0.01 sec)
```
- 상품 테이블에서는 메이커명을 메이커코드로 변경해두자. (상품2 테이블 사용)
```text
mysql> select * from 상품2;
+--------------+-----------+-----------------+--------+--------------+
| 상품코드     | 상품명    | 메이커코드      | 가격   | 상품분류     |
+--------------+-----------+-----------------+--------+--------------+
| 0001         | 상품1     | M001            |    100 | 식료품       |
| 0002         | 상품2     | M001            |    200 | 식료품       |
| 0003         | 상품3     | M002            |   1980 | 생활용품     |
+--------------+-----------+-----------------+--------+--------------+
3 rows in set (0.01 sec)
```
- 현재 두 개의 테이블로 분할되어 있지만 상품명과 메이커명을 같이 출력하고 싶을 때는 내부결합을 사용.
```text
mysql> select S.상품명, M.메이커명
    ->  from 상품2 S inner join 메이커 M
    ->    on S.메이커코드 = M.메이커코드;
+-----------+--------------+
| 상품명    | 메이커명     |
+-----------+--------------+
| 상품1     | 메이커1      |
| 상품2     | 메이커1      |
| 상품3     | 메이커2      |
+-----------+--------------+
3 rows in set (0.00 sec)
```
- 테이블에 별명을 붙였다. SELECT에서 복수의 테이블을 다룰 경우 어느 테이블의 열인지 정확하게 지정해야 함. 이떄 테이블명을 매번 지정하는 것은 번거로운
일이므로 짧게 줄여 별명을 붙이는 경우가 많음. 메이커 테이블 'M', 상품 테이블 'S'
- 상품 테이블의 메이커코드만을 살펴보면 중복하는 행 존재. 이것은 실제로 가능. 단, 기본키 제약은 상품코드에만 적용되어 있어 데이터상으로도 제약에 위반되지 않음.
반대로 메이커 테이블은 메이커코드에 기본키가 지정되어 있어 중복을 불허. 메이커코드는 유일하게 하나씩만 존재하며 중복될 수 없고 존재하지 않거나 하나만 존재.
- 이것이 핵심 개념이다. A 테이블과 B 테이블을 결합했을 때, A와 B 중 어느 쪽이 하나의 행만 가지는지 (일대다, 다대일) 아니면 양쪽 모두 하나의 행을 가지는지
(일대일) 등과 같은 '서로 결합하는 테이블 간의 관계'가 중요.

### 외부키
- 메이커 테이블의 메이커코드는 기본키. 그에 비해 상품 테이블의 메이커코드는 '외부키'라 부리는 것으로, 다른 테이블의 기본키를 참조하는 열이 외부키가 됨.

### 자기결합 (Self Join)
- 자기결합은 테이블에 별명을 붙일 수 있는 기능을 이용해 같은 테이블끼리 결합하는 것을 말함. 특별히 명령어가 정해져 있는 것은 아니다. 예제를 보자.
```text
mysql> select * from 상품;
+--------------+-----------+--------------+--------+--------------+
| 상품코드     | 상품명    | 메이커명     | 가격   | 상품분류     |
+--------------+-----------+--------------+--------+--------------+
| 0001         | 상품1     | 메이커1      |    100 | 식료품       |
| 0002         | 상품2     | 메이커2      |    200 | 식료품       |
| 0003         | 상품3     | 메이커3      |   1980 | 생활용품     |
+--------------+-----------+--------------+--------+--------------+
3 rows in set (0.00 sec)

mysql> select s1.상품명, s2.상품명
    ->  from 상품 s1 inner join 상품 s2
    ->    on s1.상품코드 = s2.상품코드;
+-----------+-----------+
| 상품명    | 상품명    |
+-----------+-----------+
| 상품1     | 상품1     |
| 상품2     | 상품2     |
| 상품3     | 상품3     |
+-----------+-----------+
3 rows in set (0.00 sec)
```
- 상품 테이블을 가로로 두 개 나열해 상품코드로 결합했다. 자기결합에서는 결합의 좌우가 같은 테이블이 되기 때문에 이를 구별하기 위해 반드시 별명을 써야 함.
- 사실 평소에는 이러한 결합을 할 일은 없지만, 자기 자신의 기본키를 참조하는 열을 자기 자신이 가지는 데이터 구조로 되어 있을 경우 자주 사용.

## 5. 외부 결합
- 결합 방법은 크게 내부결합과 외부결합의 두 가지로 구분.
- 외부결합이라 해도 교차결합으로 결합조건을 지정해 검색한다는 기본적인 사고 방식은 같다. 외부결합은 '어느 한 쪽에만 존재하는 데이터행을 어떻게 다룰지'를 
변경할 수 있는 결합 방법.
- 앞에서 살펴보았떤 상품 테이블과 재고수 테이블 중에 상품 테이블에만 행이 존재하는 상황을 생각해보자. 실제로 상품 데이터를 등록한 직후에는 이러한 상황이 존재할
수 있다. (예제 데이터베이스 안의 상품3)
```text
mysql> select * from 상품3;
+--------------+--------------+-----------------+--------+--------------+
| 상품코드     | 상품명       | 메이커코드      | 가격   | 상품분류     |
+--------------+--------------+-----------------+--------+--------------+
| 0001         | 상품1        | M001            |    100 | 식료품       |
| 0002         | 상품2        | M001            |    200 | 식료품       |
| 0003         | 상품3        | M002            |   1980 | 생활용품     |
| 0009         | 추가상품     | M001            |    300 | 식료품       |
+--------------+--------------+-----------------+--------+--------------+
4 rows in set (0.01 sec)

mysql> select * from 재고수;
+--------------+------------+-----------+
| 상품코드     | 입고일     | 재고수    |
+--------------+------------+-----------+
| 0001         | 2014-01-03 |       200 |
| 0002         | 2014-02-10 |       500 |
| 0003         | 2014-02-14 |        10 |
+--------------+------------+-----------+
3 rows in set (0.01 sec)
```
- 상품3 테이블에 상품코드가 0009인 행을 추가했는데, 재고수 테이블에는 아직 이 상품에 대한 데이터가 없다. 이런 상태에서 곱집합을 구해도 0009 = 0009가
되는 행은 존재하지 않으므로 내부결합 결과에서는 상품코드가 0009인 상품이 제외됨.
```text
mysql> select 상품3.상품명, 재고수.재고수
    ->  from 상품3 inner join 재고수
    ->  on 상품3.상품코드 = 재고수.상품코드
    ->  where 상품3.상품분류 = '식료품';
+-----------+-----------+
| 상품명    | 재고수    |
+-----------+-----------+
| 상품1     |       200 |
| 상품2     |       500 |
+-----------+-----------+
2 rows in set (0.00 sec)
```
- 이런 경우 외부결합을 사용하면 됨. 외부결합은 결합하는 테이블 중에 어느 쪽을 기준으로 할지 결정할 수 있다. 이번에는 상품 테이블(결합의 왼쪽)을 기준으로
INNER JOIN 대신 LEFT JOIN을 사용해보자.
```text
mysql> select 상품3.상품명, 재고수.재고수
    ->  from 상품3 left join 재고수
    ->    on 상품3.상품코드 = 재고수.상품코드
    ->  where 상품3.상품분류 = '식료품';
+--------------+-----------+
| 상품명       | 재고수    |
+--------------+-----------+
| 상품1        |       200 |
| 상품2        |       500 |
| 추가상품     |      NULL |
+--------------+-----------+
3 rows in set (0.00 sec)
```
- 재고수 테이블에는 0009에 대한 데이터가 없으므로 같이 NULL로 표시되는 점에 주의. 기준이 되는 상품 테이블을 JOIN의 왼쪽에 기술했으므로 LEFT JOIN이라
지정했다. 상품 테이블을 오른쪽에 지정하는 경우나 재고 테이블을 기준으로 삼고 싶은 경우에는 RIGHT JOIN을 사용해 외부 결합을 시행.
> LEFT JOIN, RIGHT JOIN으로 외부결합을 할 수 있다!

### 구식방법에서의 외부결합과 표준 SQL
- MySQL은 비교적 최근에 나온 데이터베이스이다. 따라서 구식 방법을 이용해도 내부결합은 가능하지만 외부결합은 불가.
- Oracle을 예로 알아보자.
- 구식 결합방법에서는 FROM 구에 결합조건을 기술하지 않음. 대신 WHERE 구로 결합 조건 지정. 그냥 조건식을 지정하면 내부결합이 되어버리므로, 외부결합으로
지정하고 싶을 떄 특별한 연산자 사용.
- Oracledㅔ서는 데이터가 존재하지 않을 수도 있는 테이블의 열에 (+)라는 특수한 기호를 붙여 조건식 지정.
```text
select 상품3.상품명, 재고수.재고수
    FROM 상품3, 재고수
    WHERE 상품3.상품코드 = 재고수.상품코드 (+)
      AND 상품3.상품분류 = '식료품';
```
- 그 밖에도 SQL Server 에서는 특수한 연산자 (`*=` or `=*`)를 사용해 외부 결합 가능. 이전에는 데이터베이스에 따라 서로 다른 방법으로 외부결합을
지원했다. 즉, SQL의 방언에 속함. 하지만 현재는 표준화로 인해 내부결합은 INNER JOIN, 외부결합은 LEFT JOIN이나 RIGHT JOIN을 사용하도록 권장한다.
- 표준화가 진행된 현재에는 별다른 장점이 없는 구식 결합방법은 사용하지 않는다. 따라서 어디까지나 참고로만 삼자.

> 구식 결합방법은 사용하지 않는다!

# 3-2 좀 더 깊게 알아보는 SELECT 문
- SELECT 문에는 결과의 정렬을 위한 ORDER BY, 결과의 개수를 제한하는 LIMIT, 중복된 데이터를 제거하는 DISTINCT 사용 가능.
- GROUP BY는 지정한 열의 데이터들을 같은 데이터끼리 묶어 결과 추출. 합계, 평균, 개수 등을 처리할 때 사용. GROUP BY 절에서도 HBAVING 절을 통해 조건식 추가 가능.

## ORDER BY 절
```text
select 열_이름
    from 테이블_이름
    where 조건식
    group by 열_이름
    having 조건식
    order by 열_이름
    limit 숫자
```
- order by 절은 결과의 값이나 개수에 영향 X. 결과 출력 순서를 조절.
- 데뷔 일자(debut_date)가 빠른 순서대로 출력.
```sql
select mem_id, mem_name, debut_date from member order by debut_date;
```
```text
+--------+--------------+------------+
| mem_id | mem_name     | debut_date |
+--------+--------------+------------+
| GRL    | 소녀시대     | 2007-08-02 |
| APN    | 에이핑크     | 2011-02-10 |
| MMU    | 마마무       | 2014-06-19 |
| RED    | 레드벨벳     | 2014-08-01 |
| WMN    | 여자친구     | 2015-01-15 |
| OMY    | 오마이걸     | 2015-04-21 |
| TWC    | 트와이스     | 2015-10-19 |
| SPC    | 우주소녀     | 2016-02-25 |
| BLK    | 블랙핑크     | 2016-08-08 |
| ITZ    | 잇지         | 2019-02-12 |
+--------+--------------+------------+
10 rows in set (0.01 sec)
```
- 데뷔 일자(debut_date)가 늦은 순서대로 출력하려면 desc 라고 붙여주면 됨. 기본값은 asc(ascending의 약자) 오름차순. desc는 (descending의 약자) 내림차순.
```sql
select mem_id, mem_name, debut_date from member order by debut_date desc;
```
```text
+--------+--------------+------------+
| mem_id | mem_name     | debut_date |
+--------+--------------+------------+
| ITZ    | 잇지         | 2019-02-12 |
| BLK    | 블랙핑크     | 2016-08-08 |
| SPC    | 우주소녀     | 2016-02-25 |
| TWC    | 트와이스     | 2015-10-19 |
| OMY    | 오마이걸     | 2015-04-21 |
| WMN    | 여자친구     | 2015-01-15 |
| RED    | 레드벨벳     | 2014-08-01 |
| MMU    | 마마무       | 2014-06-19 |
| APN    | 에이핑크     | 2011-02-10 |
| GRL    | 소녀시대     | 2007-08-02 |
+--------+--------------+------------+
10 rows in set (0.00 sec)
```
- order by절은 where 절과 함께 사용 가능. but, where 절 다음에 order by절이 나와야 함. (전에 나올 시 오류 발생)
```sql
select mem_id, mem_name, debut_date, height from member order by height desc where height >= 164;
```
```text
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax 
to use near 'where height >= 164' at line 1
```
```sql
select mem_id, mem_name, debut_date, height from member where height >= 164 order by height desc;
```
```text
+--------+--------------+------------+--------+
| mem_id | mem_name     | debut_date | height |
+--------+--------------+------------+--------+
| GRL    | 소녀시대     | 2007-08-02 |    168 |
| ITZ    | 잇지         | 2019-02-12 |    167 |
| TWC    | 트와이스     | 2015-10-19 |    167 |
| WMN    | 여자친구     | 2015-01-15 |    166 |
| MMU    | 마마무       | 2014-06-19 |    165 |
| APN    | 에이핑크     | 2011-02-10 |    164 |
+--------+--------------+------------+--------+
6 rows in set (0.00 sec)
```
- height 가 동일할 때 잇지가 트와이스보다 먼저 출력됨. 한가지 조건이 같을 때 다른 조건으로 정렬 조건을 붙힐 수 있음.
```sql
select mem_id, mem_name, debut_date, height from member where height >= 164 order by height desc, debut_date asc;
```
```text
+--------+--------------+------------+--------+
| mem_id | mem_name     | debut_date | height |
+--------+--------------+------------+--------+
| GRL    | 소녀시대     | 2007-08-02 |    168 |
| TWC    | 트와이스     | 2015-10-19 |    167 |
| ITZ    | 잇지         | 2019-02-12 |    167 |
| WMN    | 여자친구     | 2015-01-15 |    166 |
| MMU    | 마마무       | 2014-06-19 |    165 |
| APN    | 에이핑크     | 2011-02-10 |    164 |
+--------+--------------+------------+--------+
6 rows in set (0.00 sec)
```

## 출력의 개수를 제한 : LIMIT
- LIMIT은 출력하는 개수 제한.
```sql
mysql> select * from member limit 3;
```
```text
+--------+--------------+------------+--------+--------+----------+--------+------------+
| mem_id | mem_name     | mem_number | addr   | phone1 | phone2   | height | debut_date |
+--------+--------------+------------+--------+--------+----------+--------+------------+
| APN    | 에이핑크     |          6 | 경기   | 031    | 77777777 |    164 | 2011-02-10 |
| BLK    | 블랙핑크     |          4 | 경남   | 055    | 22222222 |    163 | 2016-08-08 |
| GRL    | 소녀시대     |          8 | 서울   | 02     | 44444444 |    168 | 2007-08-02 |
+--------+--------------+------------+--------+--------+----------+--------+------------+
3 rows in set (0.00 sec)
```
- 결과에는 문제가 없지만 기준 없이 3건만 뽑는 경우는 별로 없으므로 다음 구문을 살펴보자.
```sql
select mem_name, debut_date from member order by debut_date limit 3;
```
```text
+--------------+------------+
| mem_name     | debut_date |
+--------------+------------+
| 소녀시대     | 2007-08-02 |
| 에이핑크     | 2011-02-10 |
| 마마무       | 2014-06-19 |
+--------------+------------+
3 rows in set (0.00 sec)
```
- limit 의 형식은 `limit 시작, 개수`, limit 3만 쓰면 limit 0, 3과 동일. 즉, 0번째부터 3건이라는 의미.
- 필요하다면 중간부터 출력도 가능. 아래처럼 평균 키(height)가 큰 순으로 정렬하되, 3번째부터 2건만 조회가능.
```sql
select mem_name, height from member order by height desc limit 3, 2;
```
```text
+--------------+--------+
| mem_name     | height |
+--------------+--------+
| 여자친구     |    166 |
| 마마무       |    165 |
+--------------+--------+
2 rows in set (0.00 sec)
```
- limit 시작, 개수는 limit 개수 offset 시작 이라고 쓰는 것과 동일. 또한 limit은 첫 데이터를 0번으로 설정하고 시작.

### 중복된 결과를 제거 : DISTINCT
- distinct 는 조회된 결과에서 중복된 데이터를 1개만 남김.
- 먼저 지역(addr)을 출력해보자.
```sql
select addr from member;
```
```text
+--------+
| addr   |
+--------+
| 경기   |
| 경남   |
| 서울   |
| 경남   |
| 전남   |
| 서울   |
| 경북   |
| 서울   |
| 서울   |
| 경기   |
+--------+
10 rows in set (0.00 sec)
```
- distinct를 사용하면 아래와 같이 중복 데이터를 1개만 남기고 제거.
```sql
select distinct addr from member;
```
```text
+--------+
| addr   |
+--------+
| 경기   |
| 경남   |
| 서울   |
| 전남   |
| 경북   |
+--------+
5 rows in set (0.00 sec)
```

## GROUP BY 절
- GROUP BY 절은 말 그대로 그룹으로 묶어주는 역할.
- 회원 별로 여러 개의 물건 구매가 있었고 각 행이 별도로 출력될 것이다. 이러한 합계를 어떻게 해야 할까?
```sql
select mem_id, amount from buy order by mem_id;
```
```text
+--------+--------+
| mem_id | amount |
+--------+--------+
| APN    |      1 |
| APN    |      2 |
| APN    |      1 |
| APN    |      1 |
| BLK    |      2 |
| BLK    |      1 |
| BLK    |      3 |
| GRL    |      5 |
| MMU    |      5 |
| MMU    |     10 |
| MMU    |      1 |
| MMU    |      4 |
+--------+--------+
12 rows in set (0.00 sec)
```
- 이럴 때 GROUP BY 와 함께 집계 함수를 사용하면 됨./

### 집계 함수
- group by 와 함꼐 주로 사용되는 집계 함수 (aggregate function)

| 함수명             | 설명                    |
|-----------------|-----------------------|
| SUM()           | 합계를 구함                |
| AVG()           | 평균을 구함                |
| MIN()           | 최솟값을 구함               |
| MAX()           | 최댓값을 구함               |
| COUNT()         | 행의 개수를 셈              |
| COUNT(DISTINCT) | 행의 개수를 셈 (중복은 1개만 인정) |

- 각 회원 별로 구매한 개수를 합쳐 출력을 위해 SUM() + GROUP BY 절 사용.
```sql
select mem_id, sum(amount) from buy group by mem_id;
```
```text
+--------+-------------+
| mem_id | sum(amount) |
+--------+-------------+
| APN    |           5 |
| BLK    |           6 |
| GRL    |           5 |
| MMU    |          20 |
+--------+-------------+
4 rows in set (0.01 sec)
```
- 별칭 사용
```sql
select mem_id "회원 아이디", sum(amount) "총 구매 개수" from buy group by mem_id;
```
```text
+------------------+-------------------+
| 회원 아이디      | 총 구매 개수      |
+------------------+-------------------+
| APN              |                 5 |
| BLK              |                 6 |
| GRL              |                 5 |
| MMU              |                20 |
+------------------+-------------------+
4 rows in set (0.00 sec)
```
- 구매한 금액의 총합을 구해보자.
```sql
select mem_id "회원 아이디", sum(price * amount) "총 구매 금액" from buy group by mem_id;
```
```text
+------------------+-------------------+
| 회원 아이디      | 총 구매 금액      |
+------------------+-------------------+
| APN              |               295 |
| BLK              |              1210 |
| GRL              |                75 |
| MMU              |              1950 |
+------------------+-------------------+
4 rows in set (0.00 sec)
```
- 전체 회원이 구매한 물품 개수의 평균을 구하면 아래와 같다.
```sql
select avg(amount) "평균 구매 개수" from buy;
```
```text
+----------------------+
| 평균 구매 개수       |
+----------------------+
|               3.0000 |
+----------------------+
1 row in set (0.01 sec)
```
- 각 회원이 한 번 구매시 평균 몇 개를 구매했는 지 알아보자. (group by 사용)
```sql
select mem_id, avg(amount) "평균 구매 개수" from buy group by mem_id;
```
```text
+--------+----------------------+
| mem_id | 평균 구매 개수       |
+--------+----------------------+
| APN    |               1.2500 |
| BLK    |               2.0000 |
| GRL    |               5.0000 |
| MMU    |               5.0000 |
+--------+----------------------+
4 rows in set (0.00 sec)
```
- 다음으로 회원 테이블에서 연락처가 있는 회원의 수를 카운트해보자.
- 먼저, phone 이 null 인 데이터는 아래와 같이 2개.
```sql
select * from member;
```
```text
+--------+--------------+------------+--------+--------+----------+--------+------------+
| mem_id | mem_name     | mem_number | addr   | phone1 | phone2   | height | debut_date |
+--------+--------------+------------+--------+--------+----------+--------+------------+
| APN    | 에이핑크     |          6 | 경기   | 031    | 77777777 |    164 | 2011-02-10 |
| BLK    | 블랙핑크     |          4 | 경남   | 055    | 22222222 |    163 | 2016-08-08 |
| GRL    | 소녀시대     |          8 | 서울   | 02     | 44444444 |    168 | 2007-08-02 |
| ITZ    | 잇지         |          5 | 경남   | NULL   | NULL     |    167 | 2019-02-12 |
| MMU    | 마마무       |          4 | 전남   | 061    | 99999999 |    165 | 2014-06-19 |
| OMY    | 오마이걸     |          7 | 서울   | NULL   | NULL     |    160 | 2015-04-21 |
| RED    | 레드벨벳     |          4 | 경북   | 054    | 55555555 |    161 | 2014-08-01 |
| SPC    | 우주소녀     |         13 | 서울   | 02     | 88888888 |    162 | 2016-02-25 |
| TWC    | 트와이스     |          9 | 서울   | 02     | 11111111 |    167 | 2015-10-19 |
| WMN    | 여자친구     |          6 | 경기   | 031    | 33333333 |    166 | 2015-01-15 |
+--------+--------------+------------+--------+--------+----------+--------+------------+
10 rows in set (0.00 sec)
```
- 아래와 같이 count를 하면 10명이 나옴. 즉, null 포함
```sql
select count(*) from member;
```
```text
+----------+
| count(*) |
+----------+
|       10 |
+----------+
1 row in set (0.01 sec)
```
- 연락처만 있는 회원만 카운트하려면 phone1 또는 phone2의 열 이름을 지정해야 함.
```sql
select count(phone1) "연락처가 있는 회원" from member;
```
```text
+----------------------------+
| 연락처가 있는 회원         |
+----------------------------+
|                          8 |
+----------------------------+
1 row in set (0.00 sec)
```
- 즉, count(열_이름)은 열 이름의 값이 null인 것을 제외한 행의 개수를 셈.

### HAVING 절.
```sql
select mem_id "회원 아이디", sum(price * amount) "총 구매 금액" from buy group by mem_id;
```
```text
+------------------+-------------------+
| 회원 아이디      | 총 구매 금액      |
+------------------+-------------------+
| APN              |               295 |
| BLK              |              1210 |
| GRL              |                75 |
| MMU              |              1950 |
+------------------+-------------------+
4 rows in set (0.00 sec)
```
- 결과 중 총 구매 금액이 1000 이상인 회원만 결과를 가져오기 위한 조건은 어떻게 해야 할까?
- where 대신 having 을 사용해야 함. 비슷하게 조건을 제한하지만, 집계함수에 대해 조건을 제한하는 것. 그리고 having절은 꼭 group by 절 다음에 나와야 함.
```sql
mysql> select mem_id "회원 아이디", sum(price * amount) "총 구매 금액" from buy group by mem_id having sum(price * amount) >= 1000;
```
```text
+------------------+-------------------+
| 회원 아이디      | 총 구매 금액      |
+------------------+-------------------+
| BLK              |              1210 |
| MMU              |              1950 |
+------------------+-------------------+
2 rows in set (0.00 sec)
```
- order by도 사용 가능.
```sql
select mem_id "회원 아이디", sum(price * amount) "총 구매 금액" from buy group by mem_id having sum(price * amount) >= 1000 order by sum(price * amount) desc;
```
```text
+------------------+-------------------+
| 회원 아이디      | 총 구매 금액      |
+------------------+-------------------+
| MMU              |              1950 |
| BLK              |              1210 |
+------------------+-------------------+
2 rows in set (0.00 sec)
```

## 정리
- ORDER BY는 결과가 출력되는 순서를 조절. 오름차순인 ASC와 내림차순인 DESC 중 선택 가능.
- LIMIT 은 출력하는 개수를 제한하며, 주로 ORDER BY와 함께 사용함.
- DISTINCT는 조회된 결과에서 중복된 것은 1개만 남기며, 열 이름 앞에 붙여주면 됨.
- GROUP BY는 데이터를 그룹으로 묶어주는 기능을 함.
- HAVING은 집계 함수와 관련된 조건을 제한하며, GROUP BY 다음에 나옴.

# 확인문제 2
1. 
```sql
mysql> select * from member order by height;
```
```text
+--------+--------------+------------+--------+--------+----------+--------+------------+
| mem_id | mem_name     | mem_number | addr   | phone1 | phone2   | height | debut_date |
+--------+--------------+------------+--------+--------+----------+--------+------------+
| OMY    | 오마이걸     |          7 | 서울   | NULL   | NULL     |    160 | 2015-04-21 |
| RED    | 레드벨벳     |          4 | 경북   | 054    | 55555555 |    161 | 2014-08-01 |
| SPC    | 우주소녀     |         13 | 서울   | 02     | 88888888 |    162 | 2016-02-25 |
| BLK    | 블랙핑크     |          4 | 경남   | 055    | 22222222 |    163 | 2016-08-08 |
| APN    | 에이핑크     |          6 | 경기   | 031    | 77777777 |    164 | 2011-02-10 |
| MMU    | 마마무       |          4 | 전남   | 061    | 99999999 |    165 | 2014-06-19 |
| WMN    | 여자친구     |          6 | 경기   | 031    | 33333333 |    166 | 2015-01-15 |
| ITZ    | 잇지         |          5 | 경남   | NULL   | NULL     |    167 | 2019-02-12 |
| TWC    | 트와이스     |          9 | 서울   | 02     | 11111111 |    167 | 2015-10-19 |
| GRL    | 소녀시대     |          8 | 서울   | 02     | 44444444 |    168 | 2007-08-02 |
+--------+--------------+------------+--------+--------+----------+--------+------------+
10 rows in set (0.00 sec)
```
2.
```sql
mysql> select * from member limit 5, 2;
```
```text
+--------+--------------+------------+--------+--------+----------+--------+------------+
| mem_id | mem_name     | mem_number | addr   | phone1 | phone2   | height | debut_date |
+--------+--------------+------------+--------+--------+----------+--------+------------+
| OMY    | 오마이걸     |          7 | 서울   | NULL   | NULL     |    160 | 2015-04-21 |
| RED    | 레드벨벳     |          4 | 경북   | 054    | 55555555 |    161 | 2014-08-01 |
+--------+--------------+------------+--------+--------+----------+--------+------------+
2 rows in set (0.00 sec)
```
3.
```sql
select distinct phone1 from member;
```
```text
+--------+
| phone1 |
+--------+
| 031    |
| 055    |
| 02     |
| NULL   |
| 061    |
| 054    |
+--------+
6 rows in set (0.00 sec)
```

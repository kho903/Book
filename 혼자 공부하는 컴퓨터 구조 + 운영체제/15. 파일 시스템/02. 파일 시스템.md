# 15-02. 파일 시스템
- 파일 시스템은 파일과 디렉터리를 보조기억장치에 일목요연하게 저장하고 접근할 수 있게 하는 운영체제 내부 프로그램.
- 다양한 종류가 있고, 하나의 컴퓨터에서 여러 파일 시스템 사용 가능.

## 파티셔닝과 포매팅
- 이제 막 공장에서 생상된 새 하드 디스크 또는 SSD와 같은 보조기억장치에 곧바로 파일 생성, 저장 불가. 보조기억장치 사용을 위한 파티션을 나누는 작업(파티셔닝)과 포맷 작업(포매팅)을 거쳐야 하기 떄문.
- 파티셔닝(partitioning)은 저장 장치의 논리적인 영역을 구획하는 작업을 의미. 가령 커다란 서랍에 칸막이를 설치해 영역을 나누는 것과 작업이 바로 파티셔닝. 용량이 큰 저장 장치를 하나 이상의 논리적인 단위로 구획하는 것.
그리고 이렇게 파티셔닝 작업을 통해 나누어진 영역 하나하나를 파티션(partition)이라고 한다.
- 포맷하는 작업, 포매팅(formatting)이란 파일 시스템을 설정해 어떤 방식으로 파일을 저장하고 관리할 것인지를 결정하고, 새로운 데이터를 쓸 준비를 하는 작업을 의미. 즉, 어떤 종류의 파일 시스템을 사용할지는 이때 결정.
  - 포매팅의 종류에는 엄밀히 말하자면 저수준 포매팅과 논리적 포매팅이 있다. 전자는 저장 장치 생성 당시 공장에서 수행되는 물리적 포매팅, 후자는 파일 시스템을 생성하는 포매팅. 여기서 말하는 포매팅은 후자.
- 파일 시스템에는 여러 종류가 있고, 파티션마다 다른 파일 시스템을 설정할 수도 있다.
- 포매팅까지 완료해 파일 시스템을 설정했다면 이제 파일과 디렉터리 생성 가능. 파티셔닝과 포매팅은 동시에 진행되는 경우가 많고, 이미 포매팅까지 완료되어 판매되는 경우도 많다.

## 파일 할당방법
- 포매팅까지 끝나고 우리가 사용할 파일을 저장해보자. 운영체제는 파일과 디렉터리를 블록(block) 단위로 읽고 쓴다. 즉, 하나의 파일이 보조기억장치에 저장될 때는 하나 이상의 블록에 걸쳐 저장된다. 하드 디스크의 가장 작은
저장 단위는 섹터이지만, 운영체제는 하나 이상의 섹터를 블록이라는 단위로 묶은 뒤 블록 단위로 파일과 디렉터리를 관리. 파일 시스템이 모든 섹터를 관리하기에는 개수도 너무 많고 크기도 작기 때문.
- 블록 안에는 블록의 위치를 식별하는 주소가 있고 우리가 사용하는 파일을 할당해야 한다. 크기가 작은 파일은 적은 수의 블록에 걸쳐 저장될 것이고, 크기가 큰 파일은 여러 블록에 걸쳐 저장된다.
- 이런 상황에서 파일을 보조기억장치에 할당하는 방법에는 연속 할당과 불연속 할당이 있다. 그리고 불연속 할당에는 크게 연결 할당과 색인 할당이 있다.

### 연속 할당 (contiguous allocation)
- 연속 할당은 가장 단순한 방식으로 보조기억장치 내 연속적인 블록에 파일을 할당하는 방식,.
- 연속으로 할당된 파일에 접근하기 위해서는 파일의 첫 번째 블록 주소와 블록 단위의 길이만 알면 된다. 그렇기에 연속 할당을 사용하는 파일 시스템에서는 다음과 같이 디렉터리 엔트리에 파일 이름과 더불어 첫 번째 블록 주소와
블록 단위의 길이를 명시한다.
- 연속 할당 방식은 그저 연속적으로 저장하는 방식이기에 구현이 단순하다는 장점이 있지만, 외부 단편화를 야기한다는 치명적인 문제가 존재.

### 연결 할당 (linked allocation)
- 연속 할당의 문제를 해결할 수 있는 방식이 연결 할당이다. 각 블록 일부에 다음 블록의 주소를 저장해 다음 블록을 가리키는 형태로 할당하는 방식. 즉, 파일을 이루는 데이터를 연결 리스트로 관리. 연결 할당은 불연속 할당의
일종이기에 파일이 여러 블록에 흩어져 저장되어도 무방.
  - '어떤 블록의 주소를 저장한다'는 '그 블록을 가리킨다'와 같은 말이다. 어떤 블록의 주소를 알면 해당 블록에 얼마든지 접근 가능하기 때문.
- 연결 할당을 사용하는 파일 시스템에서는 디렉터리 엔트리에 연속 할당과 마찬가지로 파일 이름과 함께 첫 번째 블록 주소와 블록 단위의 길이를 명시한다. 디렉터리 엔트리만 보아도 어떤 파일이 어디에 저장되어 있는 지 알 수 있다.
- 연결 할당은 외부 단편화 문제를 해결하지만 단점도 존재

#### 첫째, 반드시 첫 번째 블록부터 하나씩 차례대로 읽어야 한다.
- 파이르이 중간 부분부터 접근하고 싶어도 반드시 파일의 첫 번째 블록부터 접근하여 하나씩 차례대로 읽어야 한다는 점. 파일 내 임의의 위치에 접근하는 속도, 즉 임의 접근(random access) 속도가 매우 느리다.
- 이는 성능 면에서 상당히 비효율적

#### 둘째, 하드웨어 고장이나 오류 발생 시 해당 블록 이후 블록은 접근할 수 없다.
- 하나의 블록 안에 파일 데이터와 다음 블록 주소가 모두 포함되어 있다 보니, 하드웨어 고장이나 오류로 인해 파일을 이루는 블록에 하나라도 문제 발생시 그 블록 이후의 블록에 접근 불가하다.
- 하드 디스크는 굉장히 정교하고 고장에 예민한 장치. 하드 디스크 헤드는 플래터 위에 대단히 미세한 간격으로 떨어져 있는 만큼 충격을 받으면 자칫 헤드가 플래터에 충돌해 데이터를 손상시킬 수 있다.


- 그래서 오늘날에는 그대로 구현하기 보다 조금 변형해 사용. 연결 할당을 변형한 대표적인 파일 시스템이 오늘날까지도 많이 사용하는 FAT 파일 시스템.

### 색인 할당 (indexed allocation)
- 연결 할당은 블록 일부에 다음 블록 주소를 표현하는 방식. 반면 색인 할당은 파일의 모든 블록 주소를 색인 블록 (index block)이라는 하나의 블록에 모아 관리하는 방식.
- 예를 들어 파일 a의 색인 블록은 4번이고 파일 a의 데이터는 7, 13, 11 번 블록에 저장되어 있다면 4번 블록 내에 7, 13, 11이 적혀 있고 파일 a에 순차적으로 접근하고 싶다면 색인 블록에 저장된 주소에 차례대로 접근하면 됨.
- 색인 할당은 연결 할당과는 달리 파일 내 임의의 위치에 접근하기 쉽다. 파일의 i번째 데이터 블록에 접근하고 싶다면 색인 블록의 i번째 항목이 가리키는 블록에 접근하면 되기 때문.
- 색인 블록 안에는 파일을 구성하는 데이터 블록 주소가 있으므로 색인 블록만 알면 해당 파일 데이터에 접근 가능. 그렇기에 색인 할당을 사용하는 파일 시스템에서는 디렉터리 엔트리에 파일 이름과 더불어 색인 블록 주소를 명시.
- 색인 할당을 기반으로 만든 파일 시스템이 유닉스 파일 시스템.

## 파일 시스템 살펴보기
- 다양한 파일 시스템이 있지만 대표적으로 두 가지가 있다. USB 메모리, SD 카드 등의 저용량 저장 장치에서 사용되는 FAT 파일 시스템과 유닉스 계열 운영체제에서 사용되는 유닉스 파일 시스템이다.

### FAT 파일 시스템
- 연결 할당의 단점을 보완한 파일 시스템. 연결 할당 방식의 단점의 근본적인 원인은 블록 안에 다음 블록의 주소를 저장했기 때문. 연결 할당 방식은 임의 접근의 성능이 좋지 못하고, 이 블록들 중 하나라도 문제 발생시 그 이후의
블록에는 접근 불가.
- 하지만 각 블록에 포함된 다음 블록의 주소들을 한데 모아 테이블 형태로 관리하면 단점들을 상당 부분 해소 가능. 이러한 테이블을 파일 할당 테이블(FAT;File Allocation Table)이라 부른다.
- FAT는 파일의 첫 번째 블록 주소만 알면 파일의 데이터가 담긴 모든 블록에 접근 가능하다. 그래서 디렉터리 엔트리에는 파일 이름과 더불어 파일의 첫 번째 블록 주소가 명시됨.
  - 더 이상의 다음 블록이 없으면 특별한 표시자를 표기.
- 이렇게 FAT를 이용하는 파일 시스템이 FAT 파일 시스템이다. 옛날 마이크로소프트의 MS-DOS 운영체제에서 사용되었고, 최근까지 USB 메모리, SD 카드와 같은 저용량 저장 장치용 파일 시스템으로 많이 이용되고 있다. 버전에 따라
FAT12, FAT16, FAT32가 있고 뒤의 숫자는 블록을 표현하는 비트 수 의미.
  - 윈도우에서는 블록 대신 클러스터라는 용어 사용
- FAT 파일 시스템에서 FAT는 파티션의 앞 부분에 만들어진다. FAT 영역에 FAT가 저장되고, 뒤이어 루트 디렉터리가 저장되는 영역이 있으며, 그 뒤에는 서브 디렉터리와 파일들을 위한 영역이 있다.
- FAT는 하드 디스크 파티션의 시작 부분에 있지만, 실행 도중 FAT가 메모리에 캐시될 수 있다. FAT가 메모리에 적재된 채 실행되면 기존 연결 할당보다 다음 블록을 찾는 속도가 매우 빨라지고, 결과적으로 앞선 연결 할당 방식보다
임의 접근에도 유리해짐. 즉, FAT가 메모리에 적재된 채 실행되면 임의 접근의 성능이 개선됨.
- FAT 파일 시스템디렉터리 엔트리에는 파일 이름과 더불어 파일의 첫 번째 블록 주소가 명시되는데 이외에도 FAT 파일 시스템의 디렉터리 엔트리에는 파일 속성과 관련한 다양한 정보들이 있다.
- 예를 들면, 파일 이름, 확장자, 속성, 예약 영역, 생성 시간, 마지막 접근 시간, 마지막 수정 시간, 시작 블록, 파일 크기 등이 저장됨.

### 유닉스 파일 시스템
- 다음으로 살펴볼 파일 시스템은 색인 할당 기반의 유닉스 파일 시스템으로, 색인 할당은 색인 블록을 기반으로 파일의 데이터 블록들을 찾는 방식. 유닉스 파일 시스템에서는 이 색인 블록을 i-node(index-node) 라고 부른다.
- i-node에는 파일 속성 정보와 열다섯 개의 블록 주소가 저장될 수 있다. 앞서 FAT 파일 시스템에서는 파일 속성 정보가 디렉텋리 엔트리에 표현된 것처럼 유닉스 파일 시스템에서 파일 속성 정보는 i-node에 표현된다.
- 유닉스 파일 시스템에는 파일마다 이러한 i-node가 있고, i-node마다 번호가 부여되어 있다. 그리고 i-node 들은 파티션 내 특정 영역에 모여 있다. i-node 영역에 i-node들이 있고, 데이터 영역에 디렉터리와 파일들이 있다.
- 그런데 i-node의 크기는 유한하다는 문제가 있다. i-node 하나는 기본적으로 열다섯 개의 블록 주소 저장 가능해 i-node 하나는 열다섯 개의 블록을 차지하는 파일까지 가리킬 수 있다. 하지만 블록을 20, 30 그 이상을 차지하는
큰 파일도 있ㅎ어 이 경우 i-node 하나만으로는 파일의 데이터 블록을 모두 가리킬 수 없다.
- 유닉스 파일 시스템은 이러한 문제를 다음과 같이 해결한다.

#### 첫째, 블록 주소 중 열두 개에는 직접 블록 주소 저장
- i-node가 가리킬 수 있는 열다섯 개의 블록 주소 중 처음 열두 개에는 파일 데이터가 저장된 블록 주소가 직접적으로 명시됨. 파일 데이터가 저장된 블록을 직접 블록 (direct block)이라 함. 즉, 열두 개의 주소는 직접 블록
주소를 저장하고 이것만으로 파일 데이터 블록을 모두 가리킬 수 있다면 추가적인 작업이 필요 없다.

#### 둘째, '첫째' 내용으로 충분하지 않다면 열세 번째 주소에 단일 간접 블록 주소를 저장
- 열두 개의 블록 주소로 파일의 모든 블록을 가리킬 수 없다면 i-node의 열세 번째 블록 주소를 이용한다. 열세 번째 블록 주소는 단일 간접 블록 주소를 저장.
- 단일 간접 블록(single indirect block)이란 파일 데이터가 저장된 블록이 아닌 파일 데이터를 저장한 블록 주소가 저장된 블록을 의미.

#### 셋째, '둘째' 내용으로 충분하지 않다면 열네 번째 주소에 이중 간접 블록 주소를 저장
- 열세 개의 블록 주소로 파일의 모든 블록을 가리킬 수 없다면 i-node의 열네 번째 블록 주소를 이용한다. 열네 번째 블록 주소는 이중 간접 블록 주소를 저장.
- 이중 간접 블록(double indirect block)이란 데이터 블록 주소를 저장하는 블록 주소가 저장된 블록을 의미. 즉, 단일 간접 블록들의 주소를 저장하는 블록이 이중 간접 블록.

#### 넷째, '셋째' 내용으로 충분하지 않다면 열다섯 번째 주소에 삼중 간접 블록 주소를 저장
- 열네 개의 블록 주소로 파일 블록을 가리킬 수 없다면 i-node의 열다섯 번째 블록 주소를 이용한다. 열다섯 번째 블록 주소는 삼중 간접 블록 주소를 저장.
- 삼중 간접 블록(triple indirect block)이란 이중 간접 블록 주소가 저장된 블록이다. 삼중 간접 블록까지 이용하면 웬만한 크기의 파일은 모두 표현 가능.


- 이로써 i-node만 알면 파일 속성뿐만 아니라 파일 크기가 크더라도 파일 데이터를 모두 가리킬 수 있다. i-node가 파일의 모든 것을 담고 있다 해도 과언이 아니다. 그래서 유닉스 파일 시스템의 디렉터리 엔트리도 파일 이름과
i-node 번호로 구성된다.

## 정리
- 파일 시스템을 아우르는 개념은 방대하다. 이외에도 윈도우 운영체제에서 사용되는 NT 파일 시스템(NTFS). 리눅스 운영체제에서 사용되는 ext 파일 시스템 등이 있다.

## 저널링 파일 시스템
- 컴퓨터 작업 중 갑자기 전원이 나가거나 치명적 오류로 강제로 종료된 상황을 생각해보자. 파일 시스템 변경 도중 이러한 상황(시스템 크래시)이 발생하면 파일 시스템이 훼손될 수 있다.
- 저널링 파일 시스템이 있기 전에는 이런 상황에서 부팅 직후 파일 시스템을 검사하고 복구하는 프로그램을 실행시켰다. 유닉스나 리눅스의 fsck나 윈도우의 scandisk가 이러한 프로그램에 속한다. 다만 이러한 프로그램들은
파일 시스템 내의 모든 블록에 대해 파일 시스템을 검사하기 때문에 매우 오래 걸린다는 문제가 있었다.
- 그래서 등장한 것이 저널링 기법을 이용하는 저널링 파일 시스템이다. 저널링(journaling) 기법이란 작업 로그를 통해 시스템 크래시 발생시 빠르게 복구하기 위한 방법으로 저널링 기법을 사용하는 파일 시스템에서 파일 시스템을
변경하는 작업은 다음과 같은 순서로 수행됨.
1. 작업 직전 파티션의 로그 영역에 수행하는 작업(변경 사항)에 대한 로그를 남긴다.
2. 로그를 남긴 후 작업을 수행한다.
3. 작업이 끝났다면 로그를 삭제한다.
- 이 경우 만약 작업을 하던 도중 시스템 크래시가 발생해 다시 부팅을 해야 한다면 파일 시스템 전체를 검사할 필요 없이 로그 영역에 남긴 로그만 검사해도 된다. 즉, 저널링 파일 시스템은 시스템 크래시가 발생한 직후에 로그 영역을
읽어 크래시가 발생한 당시 어떤 작업을 실행 중이었는지 알아낸 다음 해당 작업을 완료한다.
- 마이크로소프트의 NT 파일 시스템, 리눅스의 ext3, ext4 파일 시스템을 포함해 현대 대부분의 파일 시스템은 이러한 저널링 기능을 지원한다.

## 마운트
- 유닉스, 리눅스 등의 운영체제에서 '저장 장치를 마운트한다'라는 표현을 자주 사용하는데 이는 한 저장 장치의 파일 시스템에서 다른 저장 장치의 파일 시스템에 접근할 수 있도록 파일 시스템을 편입 시키는 작업을 의미.
- 예를 들어 `/, /home, /bin, /mnt` 구조를 가진 컴퓨터에서 `/, /homework, /pictures, /video, /homework/os, /homework/match, /homework/os/a.cpp, /homework/os/b.c, 
/homework/os/c.tar ...` 를 가진 USB 메모리가 있다고 가정할 때 USB 메모리의 파일 시스템을 컴퓨터의 /mnt 경로에 마운트하면 /mnt 경로에 USB 메모리의 파일 시스템이 연결된다. 즉, /mnt 경로를 통해 USB 
메모리에 접근할 수 있다. /mnt/homework/os/a.cpp 경로를 통해 a.cpp 파일에 접근할 수 있는 것.
- 유닉스, 리눅스와 같은 운영체제에서 다양한 저장 장치를 컴퓨터에 연결할 때 mount 명령어로 빈번하게 마운트한다.

## 키워드 정리
- 파티셔닝은 하드 디스크나 SSD처럼 용량이 큰 저장 장치를 하나 이상의 논리적인 여러 단위로 구획하는 작업을 의미
- 포매팅이란 파일 시스템을 설정하여 어떤 방식으로 파일을 저장하고 관리할 것인지를 결정하고, 새로운 데이터를 쓸 수 있게 하는 작업을 의미
- 연속 할당은 보조기억장치 내 연속적인 블록에 파일을 할당하는 방식
- 연결 할당은 각 블록 일부에 다음 블록의 주소를 저장하여 블록들을 연결 리스트 형태로 관리하는 방식
- 색인 할당은 파일의 모든 블록 주소를 색인 블록에 모아 관리하는 방식
- FAT 파일 시스템은 FAT를 이용하는 연결 할당 기반의 파일 시스템
- 유닉스 파일 시스템은 i-node를 이용하는 색인 할당 기반의 파일 시스템

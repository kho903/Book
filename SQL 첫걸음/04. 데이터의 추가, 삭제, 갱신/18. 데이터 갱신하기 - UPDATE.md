# 18. 데이터 갱신하기 - UPDATE
- 테이블의 셀에 저장되어 있는 값을 갱신하려면 UPDATE 명령을 사용한다.
- UPDATE 명령
```text
UPDATE 테이블명 SET 열1 = 값1, 열2 = 값2, ... WHERE 조건식
```
- 데이터 갱신 작업은 시스템을 다루는 과정에서 자주 발생. 데이터를 잘못 입력해 수정해야 하는 경우도 빈번. 이떄 실제 시스템에서 '등록'이나 '갱신' 버튼을
클릭하면 데이터 갱신이 이루어진다고 이해하면 된다.

## 1. UPDATE 로 데이터 갱신하기
- RDBMS에서는 UPDATE 명령으로 데이터를 갱신 가능. UPDATE 명령은 테이블의 셀 값을 갱신하는 명령.
- UPDATE 명령
```text
UPDATE 테이블명 SET 열명 = 값 WHERE 조건식
```
- 먼저 기존 테이블을 검색해보자.
```text
mysql> select * from sample41;
+----+------+------------+
| no | a    | b          |
+----+------+------------+
|  1 | ABC  | 2023-03-03 |
|  2 | XYZ  | NULL       |
+----+------+------------+
2 rows in set (0.01 sec)
```
- DELETE 와 달리 UPDATE 는 셀 단위로 데이터 갱신 가능. WHERE 구에 조건을 지정하면 그에 일치하는 행을 갱신 가능. WHERE 구를 생략한 경우 DELETE
의 경우와 마찬가지로 테이블의 모든 행이 갱신된다.
- UPDATE 에서는 SET 구를 사용해 갱신할 열과 값을 지정. 문법은 'SET 열명 = 값'이다. 이떄 = 은 비교 연산자가 아닌, 값을 대입하는 대입 연산자.
같은 = 이지만 연산 방법이 다르다는 점 주의! 또한 테이블에 존재하지 않는 열을 지정하면 에러가 발생해 UPDATE 명령은 실행되지 않는다.
- 값은 상수로 표기. INSERT 명령과 마찬가지로 자료형에 맞는 값을 지정해야 한다. 수치형 열에는 수치형 리터럴로, 문자열형 열에는 문자열형 리터럴로 표기.
갱신해야 할 열과 값이 복수일 경우 '열=값'을 콤마(,)로 구분해 리스트 형식으로 지정 가능. SET 구에 지정한 갱신 내용은 처리 대상이 되는 모든 행에 적용.
- sample41 의 셀 값을 UPDATE 명령으로 갱신해보자. b열이 NULL인 행의 값을 UPDATE 명령으로 갱신하자.
- 먼저, 행 지정은 WHERE no = 2로 하자. 물론 WHERE b IS NULL로도 동일한 행 지정 가능. 갱신할 값을 '2023-03-01'로 하자. 이떄 b열은 
날짜형이므로 날짜의 리터럴로 값을 표기. 그리고 UPDATE 명령을 실행하면 b열의 데이터가 갱신된 것을 확인할 수 있다.
```text
mysql> select * from sample41;
+----+------+------------+
| no | a    | b          |
+----+------+------------+
|  1 | ABC  | 2023-03-03 |
|  2 | XYZ  | NULL       |
+----+------+------------+
2 rows in set (0.00 sec)

mysql> update sample41 set b = '2023-03-01' where no = 2;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> select * from sample41;
+----+------+------------+
| no | a    | b          |
+----+------+------------+
|  1 | ABC  | 2023-03-03 |
|  2 | XYZ  | 2023-03-01 |
+----+------+------------+
2 rows in set (0.00 sec)
```
> UPDATE 명령으로 행의 셀 값을 갱신할 수 있다!
- UPDATE 명령의 WHERE 조건문 역시 DELETE 명령과 마찬가지로 조건에 일치하는 모든 행이 그 대상이 된다. 그리고 WHERE 구를 생략하면 테이블의 모든 행이
갱신 대상이 된다. 즉, WHERE 구를 생략하거나 잘못 지정할 경우 DELETE 명령에서 언급한 것처럼 의도하지 않은 처리가 발생할 수 있으므로 주의해야 한다.
> UPDATE 명령에서는 WHERE 조건이 일치하는 '모든 행'이 갱신된다!

## 2. UPDATE로 갱신할 경우 주의사항
- SET 구에서 = 은 대입 연산자다. 일단 테이블을 생성하면 INSERT 명령을 이용해 행을 추가하기 전까지 아무런 데이터도 존재하지 않는다. 하지만 행을 추가하면
되므로 아무런 문제가 되지 않는다.
- 한편, UPDATE 명령은 이미 존재하는 행에 대해 값을 갱신하므로 이전의 값과 이후의 값의 두 가지 상태를 생각할 수 있다.
- 여기에서 다음과 같은 UPDATE 명령을 실행하면 어떻게 될까?
```text
UPDATE sample41 SET no = no + 1;
```
- 이 명령문에는 WHERE 구가 지정되어 있지 않으므로 갱신 대상은 테이블의 모든 행이 된다. SET 구에서는 no 열의 값을 갱신하는데, 갱신 후의 값은 본래 값
(갱신 전의 값)에서 1을 더한 결과이다. 마치 프로그래밍 예제에 자주 등장하는 증가 연산과 같은 형식을 취한다.
```text
mysql> select * from sample41;
+----+------+------------+
| no | a    | b          |
+----+------+------------+
|  1 | ABC  | 2023-03-03 |
|  2 | XYZ  | 2023-03-01 |
+----+------+------------+
2 rows in set (0.01 sec)

mysql> update sample41 set no = no + 1;
Query OK, 2 rows affected (0.01 sec)
Rows matched: 2  Changed: 2  Warnings: 0

mysql> select * from sample41;
+----+------+------------+
| no | a    | b          |
+----+------+------------+
|  2 | ABC  | 2023-03-03 |
|  3 | XYZ  | 2023-03-01 |
+----+------+------------+
2 rows in set (0.00 sec)
```
- 실행 결과, 모든 행의 no 값에 1씩 더한 것을 알 수 있다. 이처럼 갱신할 값을 열이 포함된 식으로도 표기 가능. 이떄 해당 열이 갱신 대상이 되는 열이라
해도 상관없다.
- 앞선 실행 예의 계산식을 간단하게 설명하면 '현재의 no 값에 1을 더한 값으로 no 열을 갱신하라'는 의미. 갱신은 행 단위로 처리되므로 '현재의 no 값'은
그 행이 갱신되기 전의 값에 해당.

## 3. 복수열 갱신
- UPDATE 명령의 SET 구에서는 필요에 따라 콤마(,)로 구분해 갱신할 열을 여러 개 지정 가능
- UPDATE 명령
```text
UPDATE 테이블명 SET 열명1 = 값1, 열명2 = 값2, ... WHERE 조건식
```
- 명령문이 조금 길지만 어렵지 않다. 두 구문으로 나누어 실행하는 것보다 하나로 묶어서 실행하는 편이 더 효율적. 여기서는 a 열을 갱신하는 UPDATE 명령과
b열을 갱신하는 UPDATE 명령을 따로 실행하지 않고, a 열과 b 열을 같이 실행했다.
```sql
-- 두 구문으로 나누어 UPDATE 명령 실행
UPDATE sample41 SET a = 'xxx' where no = 2;
UPDATE sample41 SET b = '2023-03-03' where no = 2;

-- 하나로 묶어서 UPDATE 명령 실행
UPDATE sample41 SET a = 'xxx', b = '2023-03-03' where no = 2;
```

### SET 구의 실행 순서
- 여러 개의 열을 한 번에 갱신할 수 있어 편리하기는 하지만, 그 전에 SET 구는 어떤 순서로 갱신 처리를 하는지 알아둘 필요가 있다. 예를 들어 다음과 같은
2개의 UPDATE 명령이 있을 때 어떤 순서로 처리되는지 알아보자.
```text
UPDATE sample41 SET no = no + 1, a = no;
UPDATE sample41 SET a = no, no = no + 1;
```
- 이 두 UPDATE 명령은 콤마(,)로 구분된 갱신 식의 순서가 서로 다르다.
- 사실 데이터베이스 제품마다 처리 방식이 달라진다. MySQL 에서는 서로 다른 결괏값이 나오지만 Oracle 에서는 어느 명령을 실행해도 결과는 같다.
- MySQL의 경우 UPDATE 명령이 어떻게 처리되는지 알아보자. 
```text
mysql> select * from sample41;
+----+------+------------+
| no | a    | b          |
+----+------+------------+
|  2 | ABC  | 2023-03-03 |
|  3 | XYZ  | 2023-03-01 |
+----+------+------------+
2 rows in set (0.00 sec)

mysql> update sample41 set no = no + 1, a = no;
Query OK, 2 rows affected (0.00 sec)
Rows matched: 2  Changed: 2  Warnings: 0

mysql> select * from sample41;
+----+------+------------+
| no | a    | b          |
+----+------+------------+
|  3 | 3    | 2023-03-03 |
|  4 | 4    | 2023-03-01 |
+----+------+------------+
2 rows in set (0.00 sec)
```
- 첫 번째 UPDATE 를 실행하면 no 열과 a 열의 값이 서로 같아진다. no 열의 값에 1을 더해 no 열에 저장한 뒤, 그 값이 다시 a 열에 대입되기 때문.
```text
mysql> select * from sample41;
+----+------+------------+
| no | a    | b          |
+----+------+------------+
|  3 | 3    | 2023-03-03 |
|  4 | 4    | 2023-03-01 |
+----+------+------------+
2 rows in set (0.00 sec)

mysql> update sample41 set a = no, no = no + 1;
Query OK, 2 rows affected (0.00 sec)
Rows matched: 2  Changed: 2  Warnings: 0

mysql> select * from sample41;
+----+------+------------+
| no | a    | b          |
+----+------+------------+
|  4 | 3    | 2023-03-03 |
|  5 | 4    | 2023-03-01 |
+----+------+------------+
2 rows in set (0.00 sec)
```
- 다음으로 no 열의 값을 a 열에 대입한 후 , no 열의 값을 + 1 한다. 따라서 a 열의 값은 'no - 1'을 한 값이 된다.
- 하지만 Oracle의 경우는 어떻게 될까?
- Oracle의 경우
```text
- 실행 전 테이블
select * from sample41;
+----+------+------------+
| no | a    | b          |
+----+------+------------+
|  2 | ABC  | 2023-03-03 |
|  3 | XYZ  | 2023-03-01 |
+----+------+------------+
UPDATE sample41 set no = no + 1, a = no;
+----+------+------------+
| no | a    | b          |
+----+------+------------+
|  3 |   2  | 2023-03-03 |
|  2 |   3  | 2023-03-01 |
+----+------+------------+
UPDATE sample41 set a = no, no = no + 1;

+----+------+------------+
| no | a    | b          |
+----+------+------------+
|  4 |   3  | 2023-03-03 |
|  5 |   4  | 2023-03-01 |
+----+------+------------+
```
- 두 UPDATE 명령을 연속으로 실행하다 보면 값이 자꾸 증가해버려 이해하기 어려울 수 있다.
- MySQL에서는 첫 UPDATE 문 실행시 no 열과 a 열의 값은 같아진다. 하지만 두 번째 UPDATE 문 실행시 no 열과 a 열의 값은 서로 달라진다. 
- 한편 Oracle 에서는 1, 2 번 UPDATE 문을 실행해도 a 열의 값은 'no - 1' 상태를 유지한다.
- 즉, Oracle 에서는 SET 구에 기술한 식의 순서가 처리에 영향을 주지 않는다는 것을 알 수 있다. 갱신식의 오른쪽에 위치한 no 열의 값이 항상 갱신 이전의
값을 반환하기 떄문이다. 한편, MySQL에서는 SET 구에 기술된 순서로 갱신 처리가 일어나므로 no 열의 값은 갱신 이전의 값이 아닌 갱신된 이후의 값을 반환.
- 따라서, MySQL의 경우, 갱신식 안에서 열을 참조할 때는 처리 순서를 고려할 필요가 있다.

## 4. NULL 로 갱신하기
- UPDATE 명령으로 셀 값을 NULL 로 갱신할 수 있다. 따로 거창한 문법이 정해져 있는 것은 아니고, UPDATE sample41 SET b = NULL과 같이 갱신할
값으로 NULL을 지정하면 된다. 이처럼 NULL로 값을 갱신하는 것을 보통 'NULL 초기화'라 부르기도 한다.
- NULL 초기화
```text
mysql> UPDATE sample41 set a = null;
Query OK, 2 rows affected (0.00 sec)
Rows matched: 2  Changed: 2  Warnings: 0

mysql> select * from sample41;
+----+------+------------+
| no | a    | b          |
+----+------+------------+
|  4 | NULL | 2023-03-03 |
|  5 | NULL | 2023-03-01 |
+----+------+------------+
2 rows in set (0.00 sec)
```
- 다만 NOT NULL 제약이 설정되어 있는 열은 NULL이 허용되지 않는다. UPDATE 명령에 있어서도 NOT NULL 제약은 유효. no 열에는 NOT NULL 제약이
설정되어 있으므로 no 열의 셀을 NULL로 갱신할 수 없다. 즉, UPDATE sample41 SET no = NULL; 을 실행하면 NOT NULL 제약에 위반되어 에러 발생.
```text
mysql> UPDATE sample41 SET no = NULL;
ERROR 1048 (23000): Column 'no' cannot be null
```

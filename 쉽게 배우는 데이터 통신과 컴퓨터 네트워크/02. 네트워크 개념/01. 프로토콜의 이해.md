# 01. 프로토콜의 이해
- 네트워크에 연결된 시스템이 통신하려면 정해진 규칙에 따라 순차적으로 데이터를 주고받아야 하는데, 이 규칙을 프로토콜(Protocol)이라 함.
- 프로토콜 동작 과정은 전송 오류 여부, 데이터 전달 경로, 전송 속도 등 다양한 외부 요인의 영향을 받음.
- 따라서 적절한 대응 방안을 마련해 효율적으로 관리해야 하는데, 프로토콜의 설계 과정은 모듈(Module)화를 통해 이루어짐.
- 모듈화로 복잡성을 단순화하고, 사용자에게 더 편리하고 간편한 통신 기능을 제공할 수 있음.

## 1. 계층적 모듈 구조
- 일반적으로 큰 시스템의 기능은 특정 단위의 모듈로 나누어 설계.
- 각각의 모듈은 독립적으로 동작하면서도 상호 유기적으로 통합될 수 있어야 함.
- 그러므로 모듈과 모듈을 서로 연동해 동작시키는 적절한 인터페이스 필요.

### 모듈화
- 복잡한 시스템을 기능별로 모듈화하면 시스템 구조가 단순해져 전체 시스템을 이해하기 쉽다.
- 또한 각 단위 모듈이 독립적인 기능을 수행해 고장이나 업그레이드 등의 상황에 손쉽게 대처 가능.
- 소프트웨어 측면에서 프로그래밍의 함수 개념으로 모듈화 가능. 
- 각 함수가 개별적으로 설계되고 구현된다는 장점 존재. 각 함수의 역할이 매개변수로 추상화되므로 내부 구조 이해 없이 함수들을 이해앟 수 있고, 시스템도 
이해 가능.

### 계층 구조
- 분할된 모듈들은 협력 관계를 유지하며 유기적으로 동작.
- 모듈 구조는 서로 동등한 위치에서 서비스를 주고받을 수도 있고 특정 모듈이 다른 모듈에 서비스를 제공하는 형식의 계층 구조를 이루기도 한다.
- 네트워크에서는 독립적인 고유 기능을 수행하는 모듈들이 상하 계층 구조로 연결되어 동작.
- 계층 구조에서는 상위 계층이 하위 계층에 특정 서비스를 요청하는 방식으로 동작. 요청을 받은 하위 계층은 해당 서비스를 실행해 그 결과를 상위 계층에 돌려줌.
하위 계층의 실행 결과는 상위 계층에 결과 값을 직접 전달하는 방식이 될 수도 있고, 주변 환경 값을 변경하는 부수 효과 (Side Effect) 방식일 수도 있다.
- 네트워크에서 통신하는 시스템들은 계층 구조로 모듈화된 기능이 각각 동작하며, 둘 사이의 같은 계층끼리 데이터를 전달.
- 이떄 데이터를 전달하는 규칙을 프로토콜이라 함.
#### 모듈화된 계층 구조 프로토콜의 장점
- 크고 복잡한 시스템을 작고 간단한 시스템들로 재구성 가능. -> 이해하기 쉽고, 설계 및 구현 용이.
- 모듈이 연동할 수 있는 인터페이스 제공.
- 전송 매체 양단의 호스트가 수행하는 프로토콜은 상호 대칭 관계.
- 각 계층의 오류를 수정하거나 개선하는 경우 전체 시스템의 교체 없이 해당 모듈의 교체로 가능.

## 2. 프로토콜 설계 시 고려 사항
- 대표적으로 주소 표현 방법, 데이터 전송 과정의 오류 제어, 통신 양단 사이의 전송 속도를 제어하는 흐름 제어가 필요하다.
- 주소 표현은 호스트를 유일하게 구분하는 용도로 사용.
- 오류 제어는 전송 과정에서 오류 발생시 데이터 복구에 사용.
- 흐름 제어는 송신자가 데이터를 너무 빨리 보내어 수신자가 미처 처리하지 못하는 문제를 해결하기 위한 목적으로 사용.

### 주소 표현
- 상대방을 구분할 수 있는 방법 필요. 주소 체계는 시스템 설계 과정시 가장 먼저 고려해야 하는 중요 개념.
- 예 : 유선 전화의 '국가 코드-지역 코드-번호', 주민등록번호의 'yymmdd-abcdefg' 형식에서 연월일, a 성별.
- 보통 호스트마다 주소를 하나씩 부여하지만, 다수의 호스트를 묶어 하나의 그룹 주소로 표기하기도 함. 1:1과 더불어 1:N 통신 환경의 필요.
- 네트워크에 연결된 모든 호스트에 데이터를 전송할 수 있는 브로드캐스팅(Broadcasting) 표기 방법과 특정 사용자를 그룹으로 묶어서 지칭하는 멀티캐스팅
  (Multicasting) 표기 방법이 있다.

### 오류 제어
- 네트워크에서는 데이터 송수신 과정에서 오류가 발생할 수 있다.
- 전송 오류에는 데이터가 깨져서 도착하는 데이터 변형 오류와 데이터가 도착하지 못하는 데이터 분실 오류가 있다.
- 전송 오류 문제를 해결하는 오류 제어(Error Control) 기능은 통신 프로토콜의 가장 기본적인 기능에 속함.
- 데이터 변형 오류는 물리 계층의 전송 매체에 의한 물리적인 오류로, 전송 과정에서 데이터의 내용이 바뀌는 경우.
- 물리적인 오류가 아니더라도, 프로토콜의 수행 과정에서 데이터를 분실하는 논리적인 전송 오류가 발생할 수 있다.
- 네트워크 오류 제어 기능은 오류의 발생 사실을 인지하는 것이 먼저이고, 이후에 재전송 기능을 이용한 오류 복구 절차가 이어짐.
- 데이터가 분실되는 원인은 매우 다양. 전송 경로가 잘못되어 데이터가 엉뚱한 방향으로 전달되거나, 상위 계층의 논리적 처리 과정에서 분실할 수도 있음.
이를 해결하려면 먼저 오류가 발생한 사실을 인지해야 함. 이 경우, 수신 호스트가 자신에게 데이터가 보내졌다는 사실을 인지하는 것이 쉽지 않다. 그래서 보통
송신 호스트에서 타임아웃 등의 기능으로 오류를 감지하는 방법 사용.
- 데이터 변형 오류는 수신 호스트가 CRC 방식 등의 오류 검출 기법을 이용해 오류를 검출할 수 있다. 즉, 데이터 분실 오류는 송신 호스트 주도로 이루어지고,
데이터 변형 오류는 수신 호스트 주도로 이루어짐.
- 네트워크에서 전송 오류를 해결하는 일반적인 방법은 송신 호스트가 원래 데이터를 재전송(Retransmission) 하는 것.
- 물리적인 오류 외에도 통신 프로토콜에서 사용하는 알고리즘의 성격에 의해 오류가 발생하기도 함. 예로, 송신 호스트가 순차적으로 전송한 데이터의 순서가
바뀌어 도착하는 경우. 수신 호스트에서 도착 순서를 바로 잡으려면 데이터의 논리적인 순서를 의미하는 순서 번호 기능이 필요.

### 흐름 제어
- 전송 매체에서 물리적인 오류가 없었는데도 데이터를 분실하는 경우가 있는데, 이는 송수신 호스트 사이의 데이터 전송/처리 속도 차이 때문에 발생. 수신
호스트에 데이터가 도착하면 일단 내부 버퍼에 보관했다가 처리하는데, 내부 버퍼에 보관할 공간을 확보하지 못하면 데이터를 논리적으로 분실하는 결과 초래.
- 일반적으로 수신 호스트의 버퍼 처리 속도보다 송신 호스트가 데이터를 전송하는 속도가 빠르면 논리적인 데이터 분실 오류가 발생. 수신 호스트가 버퍼에 저장된
데이터를 미처 처리하지 못한 상태에서 새로운 데이터가 수신되어 일시적으로 저장할 공간이 없기 때문.
- 이 문제를 해결하려면 송신 호스트의 전송 속도를 조절하는 흐름 제어(Flow Control) 기능이 필요.
- 가장 단순한 형태의 흐름 제어 기법을 예로 보자. 송신 호스트가 데이터를 전송하려면 반드시 수신 호스트로부터 명시적은 전송 허가를 받아야 한다고 하자.
송신 호스트가 i번째 데이터를 보내고 수신 호스트가 이를 제대로 받는다. 수신 호스트는 데이터를 수신할 여력이 있을 경우에만 전송 허가를 보낸다. 전송 허가를
수신한 후에 송신 호스트가 다음 데이터인 i+1을 전송한다.
- 보통 수신 호스트의 흐름 제어에 의해 데이터 전송이 이루어짐. 위의 예와 같은 경우 실제 통신 환경에서 전송 속도가 느려 사용되지 않는다. 일반적으로 송신
호스트는 속도를 높이기 위해 동시에 여러 개의 전송 데이터를 송신할 수 있으며, 수신 호스트가 데이터 개수를 통제함.

### 데이터 전달 방식
- 프로토콜 설계 시 고려할 마지막 사항은 데이터 전달 방식.
1. 데이터를 오른쪽이나 왼쪽의 한 방향으로만 전송하는 것을 단방향(Simplex) 방식
2. 양쪽에서 데이터를 동시에 전송하는 것을 전이중(Full Duplex) 방식.
3. 특정 시점에는 한 방향으로만 전송할 수 있는 반이중(Half Duplex) 방식. 양쪽에서 데이터를 동시에 전송할 수 없어, 데이터 전송 시점을 제어할 수 
있어야 함.
- 일반적인 프로토콜은 모두 전이중 방식을 지원.
- 데이터 전달 방식에서는 데이터 사이의 전송 우선순위를 설정하는 방법이나 긴급 데이터를 처리하는 방법 등도 고려해야 함.

## 3. 서비스 프리미티브
- 프로토콜은 계층 구조로 이루어져 있고, 하위 계층이 상위 계층에 서비스를 제공하는 방식으로 동작. 이러한 서비스는 프리미티브(Primitive) 형태로 구현됨.
- 계층 구조 프로토콜에서 하위 계층이 상위 계층에 제공하는 서비스의 종류에는 연결형과 비연결형이 있음.

### 연결형 서비스 (Connection-oriented Service)
- 연결형 서비스를 이용하는 절차는 크게 3단계.
1. 데이터 전달 경로를 설정하는 연결 설정 단계
2. 연결 설정 후 데이터 전송 단계
3. 데이터 전송 완료 후 연결을 끊는 연결 해제 단계
- 연결형 서비스의 동작 원리는 전화 시스템을 이용한 통화 절차와 매우 유사

### 비연결형 서비스 (Connectionless Service)
- 비연결형 서비스는 우편 시스템의 동작 원리와 비슷. 연결을 설정하고 해제하는 단계가 필요 없다.
- 즉, 전송할 데이터가 있으면 각 데이터를 독립적으로 목적지 호스트로 전송하면 된다.
- 데이터는 독립적인 경로 선택 과정에 의해 전달되므로 도착하는 순서와 일치하지 않을 수 있다.


- 하위 계층이 상위 계층에 제공하는 서비스는 프리미티브(Primitive) 형태로 구현됨. 따라서 프리미티브는 하위 계층을 사용하는 방법을 정형화한 것.
- 연결형 서비스의 프리미티브 종류는 아래와 같다.

| 프리미티브      | 용도     |
|------------|--------|
| CONNECT    | 연결 설정  |
| DATA       | 데이터 전송 |
| DISCONNECT | 연결 해제  |

- 통신 프로토콜에서 프리미티브를 올바르게 수행하려면 각 프리미트가 아래 네 가지 기능을 포함하도록 설계해야 한다.

| 기능         | 설명                     |
|------------|------------------------|
| Request    | 클라이언트가 서버에 서비스를 요청함    |
| Indication | 서버에 서비스 요청이 도착했음을 통지함  |
| Response   | 서버가 클라이언트에 서비스 응답을 회신함 |
| Confirm    | 클라이언트에 응답이 도착했음을 통지함   |

- 클라이언트에서 서버로 전달되는 요청은 Request와 Indication으로 구현되고, 서버의 응답은 Response와 Confirm으로 구현됨.
- 클라이언트의 상위 계층이 하위 계층에 Request를 요청하면 이 요청은 하위 계층 아래에 있는 차하위 계층의 도움을 받아 서버의 하위 계층에 전달됨.
- 그러면 이 요청은 서버의 상위 계층에 Indication 형태로 전달되어 서버가 클라이언트 요청을 인지함.
- 서버에서는 해당 프리미티브를 올바르게 수신하였음을 클라이언트에 통보하기 위해 Response를 응답으로 보내고, 반대의 과정을 거쳐서 클라이언트에 Confirm
형태로 도착.
- 이와 같은 4단계 절차를 통해 하나의 서비스 프리미티브가 처리됨.

### 서비스 프리미티브 기능 요약
#### Request
- 클라이언트에서 발생.
- 하위 계층에 요구
- CONNECT.request, DATA.request, DISCONNECT.request

### Indication
- 서버에서 발생.
- 클라이언트의 Request가 있었음을 상위 계층에 알림
- CONNECT.indication, DATA.indication, DISCONNECT.indication

### Response
- 서버에서 발생
- 클라이언트로 응답
- CONNECT.response, DATA.response, DISCONNECT.response

### Confirm
- 서버에서 보낸 응답을 클라이언트로 통보
- CONNECT.confirm, DATA.confirm, DISCONNECT.confirm
